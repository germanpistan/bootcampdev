HISTORIA DE LA PROGRAMACION: 
    DECADA DE 1940: se crea el primer sistema de codificacion ENIAC. instruccion nemotecnica: una forma corta de decir, haz algo. 
    Ejemplo: move: mover datos de un procesador. es mas sencillo programar con este sistema nemotecnico. 
    no era tan amigable esto. se inventan otro tipo de lenguajes entre el 50 y 70.
    FORTRAN, BASIC Y COBOL. el mas importante fue cobol. simplifico la forma de hacer informatica. 
    aparecen evoluciones en el lenguaje. Otro lenguaje de los 60 fue BCPL, es el lenguaje precursor del C. 
    es importante xq la parte central de un sistema operativo actuales (su KERNEL) tienen escrito en C. 
    Se usa mucho hoy, combina el bajo nivel y el alto nivel, tiene sintaxis y forma de ejecutar condiciones logicas. 
    igualmente C tiene algunas carencias, algunos lo consideran dificil. 
    Otros lenguajes: decada de los 70, aparece a parte del C, es el PASCAL, se sigue usando pero no tanto. 
    el lenguaje de programacion DELFI deriva de PASCAL. Hasta ahora son todos de proposito general, esos lenguajes se concibieron para cualquier tipo de programa en ellos. 

    DECADA DE LOS 80: lenguajes de nicho. son lenguajes especializados en una o pocas tareas, que no se usan para todo. se usa mucho en defensa, es lenguaje ADA. otro es PERL se uso mucho hasta principios de los 2000, simplificaba mucho trabajabar con ficheros de texto. Evoluciono pero se usa cada vez menos. TCL es otro lenguaje. 
    DECADA DE LOS 90: boom de internet, salieron lenguajes que combinaban como nicho y generales. JAVA se diseño para sistemas embebidos (sistema pequeño que necesita pocos recursos). Applex eran pequeños programas que daban funciones a nuestro navegador. de aca derivo JAVASCRIPT nos permite dar dinamismo a un navegador. Tambien nacio PYTHON en los 90, que se usa mucho. PHP nace en 1995. tambien nacio RUBY. otro que se usa para videojuegos es LUA. 

    DECADA DE LOS 2000 a la actualidad: ACTIONSCRIPT, se uso para hacer animaciones 2d, orientadas a dibujos o web, se llamaban banners, se conoce mas como FLASH. ya no se usa mas.
    Esto dio pie como HTML y JAVASCRIPT tengan mas animaciones hoy en dia. 
    C# o .NET, para entornos WINDOWS. Lenguaje GO,SWIFT (para apps moviles), usan parte java SCALA y CLOJURE. SCRATCH es sencillo, intuitiva para aprender. 

TIPOS DE LENGUAJES DE PROGRAMACION:
    Se dividen en tipos:
        LENGUAJE COMPILADO: son aquellos que a partir de nuestro codigo se genera un programa que el procesador es capaz de ejecutar directamente a traves del sistema operativo. usan un compilador, que transforma ese lenguaje en sistema binario y lo ejecuta. se ejecuta nativamente, sin ayuda intermedia. va mucho mas rapido pero necesito un compilador que me genere esa secuencia binaria acorde a mi procesador, por eso son distintas las secuencias de procesador debido a su arquitectura, para esto deberia generar versiones para cada procesador. 
        EJEMPLOS: C, GO
        LENGUAJES INTERPRETADOS: parte igual del codigo fuente no se compila a algo que entiende el procesador, se puede compilar a algo intermedio, esto se suele llamar BITECODE. el procesador no entiende esa cosa intermedia, entonces se necesita un INTERPRETE. esto es un programa que lee el codigo, y ejecuta el programa paso a paso, pero no lo ejecuta directamente sobre el procesador, si no sobre el mismo lo ejecuta. es mucho mas lento que los compilados. 
        EJEMPLOS: JAVA, ya que se ejecuta sobre la JAVA VIRTUAL MACHINE o JVM.
        PYTHON, PERL, PHP. Tienen ventaja ya que escribo el programa por unica vez y solo necesito un interprete para ese lenguaje para ese procesador. generalmente se ejecuta en cualquier parte, ya que vale para cualquier arquitectura de procesador. 

        LENGUAJES HIBRIDOS: son lenguajes interpretados, cuyo interprete es capaz de compilar al codigo nativo segun haga falta. compilador GIT, tiene lo bueno del interprete y del compilador. 

        LENGUAJES TIPADOS o NO TIPADOS:
            TIPADOS: aquellos en lo que puedo almacenar datos pero le tengo que decir que tipo de dato es (numero, cadena de texto, etc)
            NO TIPADOS: aquellos en los que mi compilador/ interprete deduce automaticamente que tipo de dato es. 

        esta division se debe segun a su desarrollador, por ej: PHP es no tipado, C es tipado, GO es tipado, JAVA es tipado. no puedo cambiarlos. 

    TIPOS DE APLICACIONES:
        APLICACIONES WEB: ejemplos: la app web del bootcamp. 

        arquitectura: como primera capa es lo que el usuario ve (front end):
            tres elementos: HTML, CSS, JAVASCRIPT trabajan cohesionados., tiene un codigo HTML, que seria el codigo fuente. tambien tiene codigo JAVASCRIPT (la parte de la funcionalidad) interactua en forma dinamica,  hay otra parte mas los estilos CSS.
        como segunda capa: Back end de una app web: 
            es el sistema remoto (servidor, otro ordenador) que contiene la informacion que solicita el usuario. puede estar escrito en uno o multiples lenguajes. 

        APLICACIONES DE ESCRITORIO: la parte que vemos es la que el usuario interactua. tiene front y back. cambia como esta programada.  son parecidas pero cambian las tecnologias. generalmente para windows es .net o C++, en linux desarrollada C o C++. tiene mucha informacion, menus, 

        APLICACIONES MOVILES: la del celu. es muy similar a las otras. tiene front y back. tiene menos informacion, aca se centran en lo que se denomina vista con serie de acciones. todas las apps tiene F y B.

    APLICACIONES CLIENTE-SERVIDOR: son las front end y back end. 
        por ejemplo: twitter en el celu. se empezaron a usar fines de los 90. obtiene informacion de un servidor remoto, usando una aplicacion cliente. cuando se hace estan apps se usa el protocolo HTTP, para acceder a APIs. estas APIs, ayudan a devolver la informacion. una API es un conjunto de funciones que yo le pido algo con mi cliente, se lo envio a un servidor, y devuelve la informacion. se usan librerias externas, las uso y me da igual lo que haya por debajo. puedo buscar en internet las librerias que necesito para armar las APIs, para copiar los codigos y generarlas.

MEMORIA Y VARIABLES:
    LA MEMORIA es donde nuestro ordenador contiene informacion que si no la pone ahi, no puede trabajar. no es infinita la memoria, tiene una cierta capacidad, es decir un limite. a la informacion dentro de la memoria se accede por la direccion de la memoria. en caso que tengamos millones de posiciones de memoria, por eso se inventaron las variables: es un nombre humano para una posicion de memoria. por ejemplo: direcciones de memoria: numero, decimal, saluda, otro. ademas es dinamica la memoria, es decir que puedo cambiar la informacion, mantengo la palabra numero pero va cambiando la informacion dentro. 
    ejemplo:

    numero = 1234 (no me importa la posicion de memoria)
    decimal = 2.2
    saluda = hola
    otro = adios
    por esto asigno variables, para que sea mas facil usar la informacion y no me interesa las posiciones de memoria. 

    FUNCIONA con dos tipos de VARIABLES: 
        VARIABLES : pueden cambiar su valor en cualquier momento.es toda aquella que almaceno en un lugar de memoria pero durante el ciclo de programa la puedo cambiar. la mayoria de son variables.  
        VARIABLES NO CAMBIANTES o CONSTANTES: se llaman CONSTANTES, no puedo cambiar la informacion dentro. es una asignacion en la memoria que no puedo variar en la ejecucion del programa. 
        
INTRODUCCION A LOS TIPOS DE DATOS PRIMITIVOS: es un tipo de dato basico para cualquier lenguaje.
    CARACTER: representa un unico caracter o letra, o unico numero, o unico simbolo. ej. "a","9", "-".
    cada uno de estos datos ocupa un lugar unico en la memoria. la memoria almacena en este caso un numero, 
    que corresponde en la tabla de valores para cada caracter (tabla ascii).por ejemplo: cuando uso a, la memoria almacena el numero 97. 
    como se declara un caracter. primero la variable, luego =, luego el caracter. siempre se pone entre comillas simples. este tipo de dato es uno de los primitivos. 

    TEXTO: es una secuencia de caracteres. "hola". se le llama string. en memoria se representa en cada posicion de memoria una letra, y son consecutivas. entonces hace referencia a un string y se guardan numeros como el anterior. las variables de tipo string son una secuencia de numeros de memoria de tabla ascii. los caracteres ascii normales ocupan 1 bite (8 bit) en memoria. entonces un string de 4 caracteres ocupa 32 bits, o sea 4 bytes. 

    DATOS NUMERICOS:
        cual es la diferencia entre:
            variable = '1' (hace referencia en la tabla ascii al numero que contiene el caracter 1, en este caso numero 49 )
            variable = 1 (hace referencia literalmente al numero 1)
            variable = "1" (hace referencia al string 1)
    se dividen en dos, numero enteros y de coma flotante. 
    numeros=1234 (enteros)
    numeroF=1234.5678 (flotante)
    habitualmente los numeros en los lenguajes de programacion son de 32 bits o 64 bits.
    se representan en memoria como numeros binarios. ej: 1234, son 4 bytes, . algo asi :
    se cuenta de derecha a izquierda. se guardan en la memoria en octetos, de a 8 ceros y unos. 
    00000000000000000000000000000000 (32 ceros). 
    los flotantes son los decimales, se guardan una parte de la memoria la parte entera y en otra la parte decimal. 

    BOOLEANOS: solo pueden 0 o 1. en otro lenguaje puede ser true o false. 
        se representa solo en dos lugares. 

TIPOS DE DATOS COMPLEJOS:
    ARRAYS: conjunto de un mismo de dato simple. []. pueden tener multiples elementos de datos simples. por ej: 
        arrayChar= ['a','b','c','d']
        arrayString = ["hola", "adios"]
        arrayNumeros = [0,1,2,3,4,5,6]
        arrayNumeroF = [1.1,4.4,3.14] 
        conjunto de MISMO TIPO DE DATOS. 
        un array invalido seria tener un conjunto de distintos tipos de datos. 

        arrayArrays=[
            [1,2,3]
            [4,5,6]
        ]
        a esto se le llama array bidimensional. 

    TUPLAS: se usan en algunos lenguajes. los elementos no son variables o son inmutables, mientras que en los array son mutables.  
    tupla = (a,b,c)
    mapa asociativo o array asociativo: dentro tiene un elemento "clave" y asociado un elemento valor. 

    arrayCapitalesPais [
        "Ucrania" => "Kyev",
        "España" => "Madrid"
    ]
    puedo hacer referencia. estos tambien se llaman mapas, arrays que tienen un elemento clave seguido de un valor asignado a esa clave. 
    tambien existen diccionarios, que son parecidos a estos. 

OBJETOS: algo que la logica de nuestro programa intenta representar en el mundo real. pueden tener propiedades. ej: caja rectangular.
    MUNDO REAL
    caja: 
    Propiedades: 
        color: blanco
        forma: rectangular
    PROGRAMACION LENGUAJE JAVA
    
    ej en java:

    class Caja {
        String Color = "blanco";
        String Forma = "rectangular";
        int Largo =20;
    }

    los objetos tienen metodos, algo que puede alterar las propiedades. 
    Ejemplo juguete:

    juguete: 
    Propiedades: 
        color: marron
        forma: patata
    Metodos:
        Poner sombrero
        Quitar brazo


    class Juguete {
        String Color = "marron";
        String Forma = "patata";
        
        ponerSombrero(){}
        quitarBrazo (){}
    }

CONSEJOS PARA TIPOS DE DATOS:
    String 
        nombre = "German" + '0'
        este ultimo caracter indica el final de una cadena de texto. o sea que por ej: German no tiene 6 posiciones guardando, tiene 7, mas el 0. 

    los string son una conveniencia. xq es un array de caracteres por debajo. por conveniencia los lenguajes de programacion nos permiten usar el nombre = "german". pero es array. 

FUNCIONES. DEFINICION Y CONCEPTOS: nos evita tener que repetir codigo. dentro de la funcion puede ir cualquier sintaxis de lenguaje. cuando tenemos que hacer muchas veces la misma tarea, creamos una funcion para no tener que escribir muchas veces el mismo codigo. 
tienen una firma o prototipo o signature. esto consiste en: como se llama la funcion, que valores acepta, y que tipo de datos retorna la funcion en caso que lo haga. 
ejemplo en java: 
    public static int suma (int a, int b) {
        return a + b
    }
    primero pongo el tipo de dato que quiero que devuelva con int, luego dentro de los parentesis los datos que tengo que poner para invocarla y el tipo. luego lo que quiero que haga o devuelva. 

    para invocar a la funcion tengo que poner el nombre y los parametros que me pida. algunas no tienen xq devolver nada, como en java que uso void.
    cuando la funcion devuelvo algo es xq necesito ese retorno despues para otra funcion o dentro de mi programa. 

USOS DE FUNCIONES:
    los parametros o sea las variables dentro de la funcion, solo existen dentro de ellas mismas. 
    puede aceptar parametros o no las funciones. puede ser parametros de distintos tipos. puede devolver el varlor del tipo que creamos conveniente. podemos importar paquetes de codigos con funciones. los lenguajes hoy son modulares, es decir, se pueden crear conjuntos de funciones y compartirlos. esto se llaman librerias. 
    tambien tiene el cuerpo de la funcion: donde la funcion implementa su logica. tiene que ser pequeña y util. los parametros solamente existen dentro del cuerpo de la funcion. es decir que por ej: tengo un parametro a en una funcion, puedo poner una variable a fuera de la funcion y no se solapan; se pueden llamar igual siempre que no esten en la misma funcion. 

FUNCIONES AVANZADAS:
    hay dos formas de pasar parametros a las funciones:
        paso por valor: ya en la funcion defino los parametros y cuando la llamo, los valores se copian en la llamada de la funcion, en lugar de los parametros. se copia tambien el tipo de dato. por debajo se reserva el espacio de memoria cuando copio esos parametros, es decir, usa misma cantidad de memoria y ocupa dos veces, una vez cuando la defino y otra cuando la llamo.

        paso por referencia: le paso una direccion de memoria como parametro, y la funcion modifica lo que haya en esa direccion de memoria. no es copia de valor, si no que pasa una referencia de memoria. un puntero es una referencia a un area de la memoria de un ordenador. el objeto trabaja por debajo con punteros. aca uso menos memoria, que el paso por valor que se duplica la cantidad de memoria. 

    FUNCIONES RECURSIVAS: funcion que devuelve valor y que se invoca a si misma. por ejemplo un bucle de funcion suma, en donde se invoca constantemente. 
    CALLBACK: asignar el nombre de una funcion a una variable. luego invoco indirectamente a mi funcion a traves de la variable, que por debajo es funcion. en java si se puede usar, pero son interface. 

CONDICIONALES: son una serie de reglas que nosotros le ponemos al programa para que lo haga. son sentencias de control, que usan condiciones. 
los condicionales son condiciones, suelen ser que comparan una cosa con otra. 
LOGICAS:
    "Y" dos o mas cosas deben cumplirse. &&
    "O" una o mas cosas deben cumplirse   ||

COMPARATIVAS:
    "MAYOR QUE" >
    "MENOR QUE"<
    "MAYOR O IGUAL QUE" >=
    "MENOR O IGUAL QUE" <=
    "IGUAL A" ==
    "DISTINTO A" !=

se comparan cosas de izquierda con derecha. en este caso, se evalua la condicion. pueden tener dos resultados. True o False. 
las condiciones se cumplen o no. esto es logica booleana. ver tablas de la verdad. 

SI (if) se usa para declarar una condicion. 

VAR ESTACION = "VERANO"
VAR TEMPERATURA = 19
SI (ESTACION IGUAL A "VERANO") Y (TEMPERATURA MAYOR QUE 20) ENTONCES 
    AQUI LAS ACCIONES A TOMAR
    BEBER_AGUA
    BAÑARSE_EN_LA_PISCINA ()
    TOMARSE_UN_MOJITO()
    IRSE_AL_BAR()
esto seria la logica del si escrita sin codigo, solo se cumple si la palabra es verano. en caso que la palabra sea invierno, no hace nada. ESE CODIGO NO SE CUMPLE, XQ CUMPLE SOLO CON UNA PARTE, NO CON LA PARTE DE LA TEMPERATURA. si se cumplen todas las condiciones de ese condicional si se ejecutaria ese condicional. 

tambien tiene un caso contrario.

VAR ESTACION = "VERANO"
VAR TEMPERATURA = 19
SI (ESTACION IGUAL A "VERANO") ENTONCES   "if"
    AQUI LAS ACCIONES A TOMAR
    BEBER_AGUA
    BAÑARSE_EN_LA_PISCINA ()
    TOMARSE_UN_MOJITO()
    IRSE_AL_BAR()
EN CASO CONTRARIO SI (ESTACION IGUAL A "PRIMAVERA") ENTONCES  "else if" o "elif"
    SALIR_DE_PASEO()
    IR_A_VER_A_LOS_AMIGOS ()
EN CASO CONTRARIO ENTONCES:   "else"
    PONERSE_EL_ABRIGO()
    BEBER_CHOCOLATE_CALIENTE()
    VER_LA_TELE()

public class ejemplo_java {

    public static void main (String[] args) {
        String estacion = "otoño";

        if (estacion == "primavera") {
            System.out.print("Es primavera");
        }  else if (estacion =="verano") {
            System.out.println("Es verano");
        }    else {
                System.out.println( "es otra estacion...");
        }

        }
    }

BUCLES WHILE Y DO WHILE:
    un bucle es hacer algo un numero determinado de veces o indeterminado de veces. es un fragmento de codigo que se va a ejecutar n veces mientras se cumpla una condicion. 
    WHILE: mientras se cumpla una condicion se ejecuta.
    
    VAR CONTADOR = 10
    MIENTRAS (CONTADOR MAYOR A CERO) evalua primero esta condicion y ejecuta. 
        RESTA UNO AL CONTADOR

    SIGO POR AQUI

    public class ejemplo_java {

    public static void main(String[] args) {
        int contador = 10;

        while (contador > 0) {
            System.out.println("Contador vale: " + contador);
            contador = contador - 1;
            contador--; (forma corta de escribir contador = contador -1)
        }
    }
}
una iteracion es cuando comprueba la condicion y vuelve arriba, es decir, cada ciclo del while. 

DO WHILE: 
VAR CONTADOR = 10
HAZ
    RESTA UNO AL CONTADOR 
MIENTRAS (CONTADOR SEA MAYOR QUE 10)
la diferencia: el while primero evalua la condicion y luego ejecuta las acciones.
el DO WHILE primero ejecuta las acciones y luego evalua la condicion (seguro se ejecuta una vez, despues depende si cumple la condicion)

public class ejemplo_java {

    public static void main(String[] args) {
        int contador = 10;

        do {
            System.out.println(contador);
            contador = contador - 1;
        } while (contador >10);

        }
    }
    }
//en este caso muestra el 2, xq el do while primero ejecuta y despues condiciona

    en este caso primero se ejecuta la accion y despues se comprueba la condicion. haz mientras. 

BUCLES FOR: "PARA". es una mezcla de todos. 
    se suele dividir en tres partes: la parte de declaracion, la de comparacion y la de accion. 
    primer parametro inicializacion; comparacion;accion)

    VAR CONTADOR =10

    "PARA" (INICIALIZACION;COMPARACION;ACCION)
    "PARA"(;CONTADOR MAYOR QUE 0; CONTADOR IGUAL A CONTADOR MENOS 1)
        IMPRIME EL VALOR DE LA VARIABLE CONTADOR

se usa con tipos de datos complejos el bucle for. la accion del bucle for se ejecuta despues de ejecutar todo el cuerpo del for. se usan para recorrer arrays o tipos de datos compuestos. 
los whiles se pueden usar para comparar verdaderos o falsos. 
ejemplo de for para recorrer arrays:

    public class ejemplo_java {

    public static void main(String[] args) {
        int valores[] = new int [5];


        for (int i = 0; i < valores.length; i ++) {
            System.out.println(valores [i]);
        }
    }
}

//usar un bucle for para mostrar todos los elementos de un array

public class ejemplo_java {

    public static void main(String[] args) {
        int valores[] = {10,20,30,40,50};
                        // 0 < 5 (compara e imprime)
                        // 1 < 5
                        // 2 < 5
                        // 3 < 5
                        // 4 < 5
                        // 5 < 5 ESTA NO!! aca sale del bucle.
        for (int i = 0; i < valores.length; i ++) {
        for (int i = 0 : valores) "forma corta de hacer lo de arriba"
            System.out.println(valores [i]);
        }
    }
}
//usar un bucle for para mostrar todos los elementos de un array

SWITCH CASE: interruptores; una forma de control que se aplica sobre una variable o condicion. conviene usar para varias condiciones. 

VAR ESTACION = "VERANO"
DISCIERNE (ESTACION)
    CASO "VERANO"
        IMPRIME "ES VERANO"

    CASO "INVIERNO"
        IMPRIME "ES INVIERNO"

    OTRO CASO:
        IMPRIME LA ESTACION DE LA VARIABLE.

public class ejemplo_java {

    public static void main(String[] args) {
        var estacion = "VERANO";

        switch (estacion) {
            case "VERANO":
                System.out.println("es verano");
                break;
            case "INVIERNO":
                System.out.println("es invierno");
                break;
            default:
                System.out.println("estoy en default: ");
        }
    }
}

se pone un break para la ejecucion de los CASE, si no se lo pongo, no corta y ejecuta todo, y me devuelve todos los case. cuando se ejecuta la condicion de un case, se ejecuta todo lo demas hasta un break. 

public class ejemplo_java {

    public static void main(String[] args) {
        var hoy_es = "SABADO";

        switch (hoy_es) {
            case "LUNES":
            case "MARTES":
            case "MIERCOLES":
            case "JUEVES":
            case "VIERNES":
                System.out.println("hoy se labura");
                break;
            case "SABADO":
            case "DOMINGO":
                System.out.println("hoy no se labura");
                break;
        }
    }
}

OTRA FORMA MAS CORTA:

 public static void main(String[] args) {
        var hoy_es = "SABADO";

        switch (hoy_es) {
            case "LUNES":
            case "MARTES":
            case "MIERCOLES":
            case "JUEVES":
            case "VIERNES":
                System.out.println("hoy se labura");
                break;
            default:
                System.out.println("hoy no se labura");
                
        }
    }
}

GESTION DE ERRORES:
    errores tipicos de programador cuando recien empezas:

    nombrar bien las variables: por ej: VAR CONTADOR = 0. es decir que cuando veo el nombre de la variable ya se para que la uso. como no se llamaria, foo, bar, foobar. 

    el codigo sin comentarios deberia entenderse normalmente por cualquier persona. las variables deben tener buenos nombres. usando bucles for no esta mal visto que se usen variables como "i", "j" o "k". "i"= index, por eso se usa asi. cuando uso arrays bidimensionales o tridimensionales, como las matrices. en este caso uso tambien "j".
    tambien se puede usar el nombre TEMP para variables temporales.
    se usa temp para variables temporales o tmp tambien. 

    otro error es hacer un codigo y no explicar que hace ese codigo con algun comentario. es decir, comentar lo que va a hacer el codigo que sigue. 

    no se debe comentar cosas logicas que hacen los codigos, es decir, comentar de mas. por eso a veces es necesario solo comentar lo mas importante.

ERRORES DEL PROGRAMADOR:
    error mas tipico, es cuando no se mantiene la coherencia en el codigo. si lo hacemos de una forma, tenemos que seguir con la misma forma de escribirlo. hay que hacer y seguir una guia de estilos. cada empresa tiene su estilo a veces. 

    hacer copias de seguridad sobre el codigo fuente que estamos trabajando, de una carpeta a otra carpeta. lo recomedable es no tenerlo al codigo en un mismo disco duro, lo mejor es usar un control de versiones (git hub). 

    usar las formas mas sencillas de lenguaje en vez de las mas complejas, las abreviadas. el error seria no usar las formas mas simples. 

    depurar un mensaje usando el print o lo que sea que muestre en pantalla; eso no se hace. para esto existe una herramienta llamada depurador. no intentar depurar usando el print, si no el soft del depurador. 

    crear funciones que son grandes. tienen que tener un cometido identificable, y tambien deberian simplificar el codigo. intentar crear funciones pequeñas, no funciones dentro de funciones si no es necesario. la funcion tiene que ser concreta. 

    REPERCUSION DE LOS ERRORES:
        perdida de precision: es cuando tengo un tipo de dato y lo convierto a otro, a veces pierdo el valor original. suponemos tengo un valor flotante y lo convierto a un valor entero, hago una conversion de tipo, pero pierdo esa parte decimal.  la solucion a este problema no es hacer un cast, es que yo cambie el tipo de parametro que recibe mi funcion. entonces ahi si no haria falta cambiar el tipo de dato de ingreso y no pierdo parte decimal. 

        otro error tipico: error de out of bounds ( off-by-one).
            tengo un array de 5 elementos y quiero imprimir la posicion 0. resulta que cuando quiero imprimir una posicion por ej 5, no es el numero 5, si no el numero 4, porque se empieza a contar desde 0. el numero 5 seria la 6ta posicion. se accede con el numero de posicion -1 pero se declara con la posicion normal, es decir con los numeros de elementos que queremos. 

        error de overflow: cuando a un tipo de dato le asigno un valor por encima de su maximo o por debajo de su minimo. por ej.: byte, que tiene 127 o 128, le asigno un valor mas grande y creo un overflow. cuando le paso uno por encima del maximo, empieza a contar del minimo y tengo un numero mas chico. 

DEPURACION DE CODIGO: en buscar programas o anomalias durante la ejecucion de nuestro programa. a veces ocurre un fallo en nuestro programa, entonces ahi usaremos y valoramos un depurador. un buen desarrollador depura utilizando un depurador. se puede usar depuracion remota. funcionan mediante puntos de ruptura. un punto de ruptura es una parte en la que nosotros le decimos al programa que debe parar, y cuando el programa para, nos aparece el depurador. se debe insertar un punto de ruptura. para crearlo tengo que hacer click normal al lado de la linea de codigo donde quiero que se haga la ruptura y se pone en color rojo, dependiendo el soft que use. no solo se puede bloquear el codigo para verlo en el momento que yo quiera el estado de las variables, si no que tambien puedo modificarlas para evaluar el comportamiento posterior al programa ante casos no esperados. 
watcher: o watch point, que solamente se dispara cuando se cumple una condicion, es como un break point de los anteriores pero solo se ejecuta si se cumple cierta condicion. se hace con boton derecho sobre el punto rojo. se le escribe la condicion y luego aparece el punto rojo con un signo de pregunta. 

public class Main {

    public static void main(String[] args) {
        int suma = 0;

        suma = suma + 16;

        System.out.println(suma);
    }
}
// proximo error de out of bounds.

public class Main {

    public static void main(String[] args) {
        int valores [] = new int [5];
        int posicion = 5;

        System.out.println(valores [posicion]);
    }
}

tambien tiene algo que se llama pila de llamada, para saber por donde paso mi programa. o sea cuando tengo varias funciones, y hago debug, al costado aparece una ventana en donde me dice por donde anda mi programa, y en que linea fue pasando. 

public class Main {

    public static void main(String[] args) {
        funcion1();
    }

    public static void funcion1() {
        funcion2();

    }
    public static void funcion2() {
        funcion3();

    }
    public static void funcion3() {
        funcion4();

    }
    public static void funcion4() {
        System.out.println("Vaya viaje que nos estamos dando");
        
    }
}


INTRODUCCION A LA PROGRAMACION ORIENTADA A OBJETOS:
    un objeto pretendemos que sea una entidad que represente a un objeto del mundo real. tienen propiedades, colores, peso, medidas, etc. tambien tiene metodos, algunos objetos tienen metodos, por ej: auto, metodo abrir puerta, cerrar, etc. se declaran mediante clases, o funciones, en java se declaran igual que los demas lenguajes mas usados. 
    primero tengo que crear una clase, como en el ejemplo abajo de java, y luego para crear un objeto de esa clase tengo que instanciarlo, significa que creo una zona en la memoria a traves de una variable para que contenga lo que tenga la clase coche, creo el objeto que uso despues. para crear una instancia de una clase, primero pongo el nombre de mi clase, seguido de la variable y ahora instanciarlo, es igual a new y el objeto.  

      Coche coche = new Coche ();

    las funciones dentro de una clase se llaman metodos. las variables de la clase son independientes. 


class Coche {
    int numeroDePuertas;
    int velocidadMaxima;
    float velocidadActual;

    public void acelerar() {
        velocidadActual += 15;
    }

    public void decelerar() {
    }
}

cuando instancio objetos comparten las mismas propiedades pero no los mismos metodos, es decir no son los mismos. a cada objeto asigna un espacio de memoria como si fuera una variable. 
podemos crear multiples objetos a partir de una clase. cada una de estas variables (objetos) tiene cada una de las propiedades independientes de las otras. 


public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();
        System.out.println(coche.velocidadActual);
        coche.acelerar();
        System.out.println(coche.velocidadActual);

        Coche coche2 = new Coche();
        System.out.println(coche2.velocidadActual);
    }
}

class Coche {
    int numeroDePuertas;
    int velocidadMaxima;
    float velocidadActual;

    public void acelerar() {
        velocidadActual += 15;
    }

    public void decelerar() {
    }
}


cuando no creo un constructor, java automaticamente lo hace por mi. cuando yo creo un constructor,java ya no lo hace. un CONSTRUCTOR es una forma de inicializar las propiedades de una clase cuando la instanciamos. 
CREAR UN CONSTRUCTOR EN JAVA:
como no devuelve dato es publico. y el nombre del constructor tiene que ser igual al de la clase. creo el constructor:   

public Coche (){
        System.out.println("Estoy en el constructor");
    }

y se ejecuta luego de que creo el new coche, en ese momento se dispara el constructor. 
cuando creo mi objeto instanciandolo, se dispara el constructor, y en el constructor puedo poner las variables o propiedades iniciales.


public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();
        System.out.println(coche.numeroDePuertas);
        System.out.println(coche.velocidadMaxima);
        System.out.println(coche.velocidadActual);

    }
}

class Coche {
    int numeroDePuertas;
    int velocidadMaxima;
    float velocidadActual;

    public Coche (){
        numeroDePuertas =5;
        velocidadMaxima = 120;
        System.out.println("Estoy en el constructor");
    }
    public void acelerar() {
        velocidadActual += 15;
    }

    public void decelerar() {
    }
}


SOBRECARGA: consiste en que puedo tener dos funciones con el mismo prototipo pero distinto parametros. puedo poner los dos constructores con mismo prototipo pero distintos parametros, uno con parametros y otro sin. 

 public Coche (){
        numeroDePuertas = 5;
        velocidadMaxima = 120;
        System.out.println("Estoy en el constructor sin nada");
    }

    public Coche (int puertas, int velocidad){
        numeroDePuertas = puertas;
        velocidadMaxima = velocidad;
        System.out.println("Estoy en el constructor CON PARAMETROS ");
    }

el constructor es el mejor lugar para inicializar las propiedades de una clase. 
ESTO ES SOBRECARGA DEL CONSTRUCTOR:

public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();
        System.out.println(coche.numeroDePuertas);
        System.out.println(coche.velocidadMaxima);
        System.out.println(coche.velocidadActual);

        Coche coche2 = new Coche(2,90);
        System.out.println(coche2.numeroDePuertas);
        System.out.println(coche2.velocidadMaxima);
        System.out.println(coche2.velocidadActual);
    }
}

class Coche {
    int numeroDePuertas;
    int velocidadMaxima;
    float velocidadActual;

    public Coche (){
        numeroDePuertas = 5;
        velocidadMaxima = 120;
        System.out.println("Estoy en el constructor sin nada");
    }

    public Coche (int puertas, int velocidad){
        numeroDePuertas = puertas;
        velocidadMaxima = velocidad;
        System.out.println("Estoy en el constructor CON PARAMETROS ");
    }
    public void acelerar() {
        velocidadActual += 15;
    }

    public void decelerar() {
    }
}

generalmente se le ponen los mismos nombres de variables cuando creo y defino la clase, con los parametros de la funcion de constructor. entonces para que no ocurra un problema. se le antepone a los definidos en la clase la palabra "this." .

class Coche {
    int numeroDePuertas;
    int velocidadMaxima;
    float velocidadActual;

    public Coche (){
        numeroDePuertas = 5;
        velocidadMaxima = 120;
        System.out.println("Estoy en el constructor sin nada");
    }

    public Coche (int numeroDePuertas, int velocidadMaxima{
        this.numeroDePuertas = numeroDePuertas
        this.velocidadMaxima = velocidadMaxima;
        System.out.println("Estoy en el constructor CON PARAMETROS ");
    }

PRIVACIDAD, ABSTRACCION Y ENCAPSULACION: 
cuando se define una clase, tiene propiedades:

    CLASE MICLASE
        PROPIEDAD1;
        PROPIEDAD2;

        FUNCION1();
        FUNCION2();

------PROGRAMA PRINCIPAL-------
    MICLASE unclose = new MICLASE()    / VAR unaclase INSTANCIA DE MICLASE.
                                       / unaclase.PROPIEDAD1 = valor
                                       IMPRIME unaclase.PROPIEDAD2

cuando se puede acceder desde fuera de una clase a una propiedad, decimos que es publica. pueden ser publicas o privadas. una propiedad privada solo se puede usar dentro de la implementacion de la clase, y cuando es publica la puedo usar dentro de la clase, o en mi programa. en caso de java, cuando es publica le ponemos "public" y cuando es privada "private". 
ENCAPSULACION: jugar con los tipos publicos y privados de forma que desde la clase los manipule y desde fuera de la clase los pueda implementar. para eso a las propiedades de la clase las declaramos privada. y luego creamos dos funciones por cada propiedad, que serian las geters y seters. xq tienen como tarea modificar la propiedad o darnos el valor de la propiedad. se dice encapsulacion xq estamos encapsulando las propiedades para acceder a ellas a traves de funciones. 

CLASE MICLASE
        PRIVADA PROPIEDAD1;
        PRIVADA PROPIEDAD2;

        FUNCION SETTERPROPIEDAD1(TEXTO valor);
            ESTA_CLASE.PROPIEDAD1 = valor

        FUNCION GETTERPROPIEDAD1() TEXTO;
            DEVUELVE EL VALOR DE ESTA_CLASE.PROPIEDAD1

los setter nunca devuelven nada y toman como tipo de dato el de la propiedad. 

class Vehiculo {
    private String tipo;

    public void SetTipo (String valor) {
        this.tipo = tipo;
    }
}

en este siguiente caso, uso setter y get para traer las propiedades encapsuladas e imprimirlas. 

import java.beans.VetoableChangeListener;

public class Main {

    public static void main(String[] args) {
        Vehiculo coche = new Vehiculo();
        coche.setTipo("Coupe");

        Vehiculo moto = new Vehiculo();
        moto.setTipo("Scooter");

        System.out.println(coche.getTipo());
        System.out.println(moto.getTipo());

    }
}

class Vehiculo {
    private String tipo;

    public void setTipo (String tipo) {
        this.tipo = tipo;
    }

    public String getTipo () {
        return this.tipo;
    }
}

OTRO EJEMPLO DE CODIGO JAVA CON ENCAPSULACION:

import java.beans.VetoableChangeListener;

public class Main {

    public static void main(String[] args) {
        Vehiculo coche = new Vehiculo();
        coche.setTipo("Coupe");
        coche.setVelocidadMaxima(120);

        Vehiculo moto = new Vehiculo();
        moto.setTipo("Scooter");
        moto.setVelocidadMaxima(50);

        System.out.println(coche.getTipo());
        System.out.println(coche.getVelocidadMaxima());
        System.out.print(moto.getTipo() + " " + moto.getVelocidadMaxima());

    }
}

class Vehiculo {
    private String tipo;
    private int velocidadMaxima;


    public void setVelocidadMaxima (int velocidadMaxima) {
        this.velocidadMaxima=velocidadMaxima;
    }

    public int getVelocidadMaxima() {
        return this.velocidadMaxima;
    }
    public void setTipo (String tipo) {
        this.tipo = tipo;
    }

    public String getTipo () {
        return this.tipo;
    }
}

NO ES NECESARIO CREAR GETER Y SETER PARA PROPIEDADES QUE VAMOS A UTILIZAR DENTRO DE NUESTRA CLASE. 

cuando tenemos una variable del tipo boolean , para usar los set y get, la variable en el geter se llamar "is" seguido del nombre de la variable. si se usa programacion multihilo, o que la clase tenga info de su estado, y que esas variables se puedan modificar a traves de los geter y seters, cuando se invocan, podrian tener codigo adicional que hiciera otras cosas. la multihilo, consiste en que tu programa se ejecuta con dos o mas cosas a la vez. 

ABSTRACCION:
    consiste en que implemento parte de mi clase, y dejo la otra parte a su libre albedrio. un metodo abstracto, suele tener un calificador. 
    una clase abstracta es igual a la normal pero en ciertos momentos esa clase tambien puede implementar el codigo de algunas funciones abstractas. implementan la funcion de forma parcial. 

    esto se hace cuando uso una clase abstracta, que es derivada si o si de una clase. en esta funcion derivada o abstracta tengo que usar si o si funciones abstractas. 

CLASE ABSTRACTA VEHICULO
        PRIVADA TIPO;
        PRIVADA SONIDO;

        FUNCION SETTERTIPO(TEXTO valor);
            ESTA_CLASE.TIPO = valor

        FUNCION GETTERTIPO(TEXTO valor);
            DEVUELVE ESTA_CLASE.TIPO;

        FUNCION ABSTRACTA SETTERSONIDO() TEXTO;
            ESTA_CLASE.SONIDO = sonido 

        FUNCION ABSTRACTA GETTERSONIDO() TEXTO;
            DEVUELVE ESTA_CLASE.sonido 

CLASE COCHE
    FUNCION SETTERSONIDO (TEXTO sonido)
    FUNCION GETTERSONIDO () TEXTO.

entonces las clases abstractas son parciales, xq te dan la mitad de codigo hecho y la otra mitad tenes que hacerlo vos. te dan el prototipo de funcion. 

HERENCIA, POLIMORFISMO E INTERFACES:
la herencia consiste en que una clase hereda metodos y propiedades de otra clase. a la que hereda se le llama HIJA. y a la clase que cede sus funciones se puede llamar clase base o principal. 

    CLASE VEHICULO
        PRIVADA VELOCIDAD MAXIMA;
        PRIVADA TIPOGASOLINA;

        FUNCION diHola()
            IMPRIME "Hola"

    CLASE COCHE HEREDA DE VEHICULO Y NO QUIERO QUE PUEDAN HEREDAR DE MI  /esto se puede agregar
        (heredada) VELOCIDADMAXIMA
        (heredada) TIPOGASOLINA
        NUMERO_DE_PUERTAS;

        (heredada) FUNCION diHola()
            IMPRIME "Hola"

        FUNCION SETTERNUMERODEPUERTAS (INTEGER puertas)
            ESTA_CLASE.NUMERODEPUERTAS = puertas

        FUNCION GETTERNUMERODEPUERTAS() INTEGER
            DEVUELVE ESTA_CLASE.NUMERO_DE_PUERTAS

    CLASE COUPE HEREDA DE COCHE XXXXXX  /esto no se permitiria xq coche no deja heredar para abajo 
        (heredada) VELOCIDADMAXIMA
        (heredada) TIPOGASOLINA
        (heredada) NUMERO_DE_PUERTAS;

        (heredada) FUNCION diHola()
                   IMPRIME "Hola"

        (heredada) FUNCION SETTERNUMERODEPUERTAS (INTEGER puertas)
                   ESTA_CLASE.NUMERODEPUERTAS = puertas

        (heredada) FUNCION GETTERNUMERODEPUERTAS() INTEGER
                 DEVUELVE ESTA_CLASE.NUMERO_DE_PUERTAS
 
 esto es herencia multiple, es decir que la clase coupe hereda propiedades de la clase coche, que a su vez hereda propiedades de vehiculo. cada clase hereda las funciones de su clase padre y añade las suyas propias. 

una FINAL CLASS es una clase a la cual no vamos a poder heredar, no deja que nadie herede de ella. 
utilizo una clase padre cuando tengo la certeza que no voy a necesitar mas metodos de los que hay en esa clase. en cambio en la clase hija, necesito mas metodos aparte de los que ya trae de la clase padre. 
las clases abstractas sirven para implementar clases parcialmente. entonces con esto delego en las clases hijas como hacer las cosas, pero en la clase padre pongo los metodos abstractos. los metodos abstractos me dicen que tengo que hacer pero no me dicen como. 

import java.beans.VetoableChangeListener;

public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();
        coche.setSonido("BRRR");
        System.out.println(coche.getSonido());


    }
}

abstract class  Vehiculo {
    int velocidadMaxima;
    String matricula;
    String sonido;

    public Vehiculo (){
        System.out.println("Estoy en el constructor de Vehiculo");
    }

    abstract public String getSonido();
    abstract public void setSonido (String sonido);

    public void setSonido() {}
    }


class Coche extends Vehiculo {
    public String getSonido(){
        System.out.println("Soy un super sonido " + this.sonido);
        return this.sonido;
    }
    public void setSonido (String sonido) {
        this.sonido = sonido;
    }

}

class Moto extends Vehiculo {
    public String getSonido (){
        return "soy un sonidillo de moto: " + this.sonido;
    }


    public void setSonido(String sonido) {

    }


}


HAY MULTIPLES TIPOS DE HERENCIA: es la relacion que nosotros creamos entre las clases. 
le herencia multiple consiste en que una clase hereda de dos o mas clases padres. 
la herencia simple una clase hereda de otra. 
la herencia multinivel es igual, salvo que hay mas clases que van heredando de otras. 
La herencia multiple una clase herada de dos o mas clases. 

CLASE VEHICULO
        PRIVADA VELOCIDAD MAXIMA;

        FUNCION diHola()
            IMPRIME "Hola"
CLASE MOTOR
    PRIVADA TIPOGASOLINA;    

    CLASE COCHE HEREDA DE VEHICULO. y de MOTOR  Y NO QUIERO QUE PUEDAN HEREDAR DE MI  /esto se puede agregar
        (heredada) VELOCIDADMAXIMA   /esta seria clase multinivel, xq hereda metodos y propiedades de dos clases distintas. 
        (heredada) TIPOGASOLINA
        NUMERO_DE_PUERTAS;

        (heredada) FUNCION diHola()
            IMPRIME "Hola"

        FUNCION SETTERNUMERODEPUERTAS (INTEGER puertas)
            ESTA_CLASE.NUMERODEPUERTAS = puertas

        FUNCION GETTERNUMERODEPUERTAS() INTEGER
            DEVUELVE ESTA_CLASE.NUMERO_DE_PUERTAS


HERENCIA JERARQUICA: de una clase base, derivan otras clases, y despues derivan mas clases, una especie de arbol de jerarquia. 

CLASE A
CLASE B HEREDA DE A
    CLASE UNO HEREDA DE B
    CLASE DOS HEREDA DE B
CLASE C HEREDA DE A
    CLASE PERRO HEREDA DE C
    CLASE GATO HEREDA DE C
CLASE D HEREDA DE A
    CLASE COCHE HEREDA DE D
    CLASE MOTO HEREDA DE D 

como que hubiera una especie de jerarquias. 

HERENCIA HIBRIDA:
    combina modelos de herencia. 

CLASE A
    CLASE B HEREDA DE A
    CLASE C HEREDA DE A

CLASE D HEREDA DE B Y HEREDA DE C
si se dibuja es una especie de rombo.

POLIMORFISMO: consiste en que las clases hijas implementan la misma funcion pero hacen distinta cosa. 

CLASE VEHICULO
        PRIVADA VELOCIDAD MAXIMA;

        FUNCION diHola()
            IMPRIME "Hola"
CLASE MOTOR
    PRIVADA TIPOGASOLINA;    

    CLASE COCHE HEREDA DE VEHICULO. y de MOTOR  
        (heredada) VELOCIDADMAXIMA  . 

        (heredada) FUNCION diHola()
            IMPRIME "soy un robot y se contar "

        FUNCION SETTERNUMERODEPUERTAS (INTEGER puertas)
            ESTA_CLASE.NUMERODEPUERTAS = puertas

        FUNCION GETTERNUMERODEPUERTAS() INTEGER
            DEVUELVE ESTA_CLASE.NUMERO_DE_PUERTAS
derivo una funcion de una clase base, y la tengo en mi clase hija. pero no quiero que haga lo que hacia en la clase base, entonces la puedo reescribir "overwrite" y que haga lo que yo quiero que haga en la clase hija. 
import java.beans.VetoableChangeListener;

public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();
        coche.diHola();

    }
}

class  Vehiculo {
    int velocidadMaxima;

    public void diHola () {
    System.out.println( "Hola!!");
    }
}

class Coche extends Vehiculo {
    public void diHola (){
        System.out.println("Soy un coche");
    }
}

la funcion es ejecutada en la instancia mas cercana, si no existe en este caso en la clase derivada, ejecuta de la clase padre. 

algunos lenguajes tienen polimorfismo a nivel de funciones, como que una misma funcion puede aparecer muchas veces en una misma clase devolviendo valores diferentes o aceptando parametros diferentes. 
Ej:

FUNCION SumaNumeros(ENTERO a, ENTERO b) ENTERO
    DEVUELVE A +B

FUNCION SumaNumeros (FLOTANTE a, FLOTANTE b) FLOTANTE
    DEVUELVE A +B

FUNCIONA SumaNumeros (DOUBLE a, DOUBLE b) 
    IMPRIME A + B

import java.beans.VetoableChangeListener;

public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();
        coche.diHola();

        coche.sumaNumeros(32, 5.4);

    }
}

class  Vehiculo {
    int velocidadMaxima;

    public void diHola () {
    System.out.println( "Hola!!");
    }
}

class Coche extends Vehiculo {
    public void diHola (){
        System.out.println("Soy un coche");
    }

    public int sumaNumeros (int a, int b) {
        System.out.println("Soy el sumaNumeros de INT");
        return a + b;
    }

    public float sumaNumeros (float a, float b) {
        System.out.println("Soy el sumaNumeros de float");
        return a + b + (float) 9.0;
    }

    public void sumaNumeros (double a, double b) {
        System.out.println("Soy el sumaNumeros de double");
        System.out.println( "El resultado es: " + (a + b));

    }
}

esto tambien se llama sobreescritura de metodos. 

INTERFACES: 
son parecidas a las clases abstractas pero no nos implementan ninguna funcion, si no, que nos dicen lo que nosotros tenemos que implementar. 

INTERFACE COCHE
    FUNCION ACELERAR(NUMERO CUANTAVELOCIDAD)
    FUNCION FRENAR (NUMERO CUANTAVELOCIDAD)

cuando yo creo una clase tengo que implementar los metodos que esa interface ha decidido. una forma que yo tengo para decirle a un programador que cuando implementa una clase tiene que tambien implementar los metodos que yo tengo definidos en una interface. 
yo creo una interface, le digo que es lo que tiene que tener las clases que se creen a partir de ahi. 

import java.beans.VetoableChangeListener;

public class Main {

    public static void main(String[] args) {


    }
}

interface Vehiculo {
    void Acelerar (int cuantaVelocidad);
    void Frenar (int cuantaVelocidad);
        }

class Coche implements Vehiculo {
    public void Acelerar(int cuantaVelocidad) {
            }

    public void Frenar (int cuantaVelocidad) {

    }

}

class Moto {

}

una interface nos da una serie de funciones o incluso variables, que necesitamos implementar en las clases que creemos. 

METODOS DE CLASE:
CLASE A
    PROPIEDAD1
    PROPIEDAD2

metodo de clase: es una funcion dentro de la clase. signature o firma tienen o prototipo. es la forma en la que la declaramos. declara el ambito: public o private, 
(VISIBILIDAD) (NOMBRE_METODO) (PARAMETROS) (VALOR)
PUBLICA leerLibros (TEXTO libro) TEXTO contenido
obligatorio poner si es publica o privada, obligatorio el nombre, opcional los parametros y opcional lo que devuelve.
para invocar a los metodos tengo que crear un objeto e instanciarlo, es decir:
Coche coche = new Coche();
        coche.Acelerar(60);

cuando el metodo esta en otra clase, tengo que crear una instancia (objeto) para poder llamar a ese metodo. luego la invocare mediante nombrevariable.nombremetodo(parametros).

puedo escribir una funcion en el main, y como parametro puedo poner una interfaz. 

 public static void EjecutaAcelerar (Vehiculo vehiculo) {
        
    }
en realidad en este caso pido al programador que me pase como parametro de esa funcion el nombre de una clase que implemente esa interfaz. 
la interfaz obliga a un programador a usar esos metodos, por eso yo requiero como parametro una clase que implemente esa interfaz.

import java.beans.VetoableChangeListener;

public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();
        EjecutaAcelerar(coche);

    }

    public static void EjecutaAcelerar (Vehiculo vehiculo) {
        vehiculo.Acelerar(15);

    }
}

interface Vehiculo {
    int variables = 0;
    void Acelerar (int cuantaVelocidad);
    void Frenar (int cuantaVelocidad);
        }

class Coche implements Vehiculo {
    public void Acelerar(int cuantaVelocidad) {
        System.out.println("Coche() -> Acelerar()");
            }

    public void Frenar (int cuantaVelocidad) {
        System.out.println("Coche() -> Frenar()");

    }

}

se dice que una clase satisface una interface, cuando esa clase implementa todos los metodos de esa interfaz. 
esto se llama metaprogramacion, xq no los puedes ejecutar de forma diferente. mientras cumplas el prototipo, el como lo hagas es de forma independiente. 

INTERFAZ USUARIOS
    METODO GETUSUARIO()

CLASE USUARIOSTXT IMPLEMENTA LA INTERFAZ USUARIOS /funciones por debajo que cambian 
    METODO GETUSUARIOS()
        LEER FICHERO.TXT
        DEVOLVER TODAS LAS LINEAS 

CLASE USUARIOSBBDD IMPLEMENTA LA INTERFAZ USUARIOS  /funciones por debajo que cambian 
    METODO GETUSUARIOS()
    CONECTARME A MYSQL
    EJECUTAR "SELECT" "FROM...."
    DEVOLVER TODOS LOS RESULTADOS

CLASE USUARIOSREDIS IMPLEMENTA LA INTERFAZ USUARIOS  /funciones por debajo que cambian 
    METODO GETUSUARIOS()
        CONECTATE A REDIS
        DEVOLVER TODOS LOS USUARIOS

FUNCION LISTARUSUARIOS (NECESITO INTERFAZ USUARIOS)  /funcion envoltorio NO CAMBIA
    DE LA INTERFAZ_USUARIOS EJECUTA EL METODO GETUSUARIOS  /siempre llama nombre de interfaz y metodo

INVOCO A LISTARUSUARIOS (TE DOY OBJETO USUARIOSREDIS)

lo que cambia aca es la implementacion del codigo get usuarios, que fue decidida en las implementaciones de la interfaz. es una especie de crear el envoltorio para satisfacer la interfaz y luego en las clases puedo modificar los metodos. 
esa funcion envoltoria invoca por debajo a la real, la real puede cambiar pero la envoltorio no cambia para nada. 

import java.beans.VetoableChangeListener;

public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();
        Moto moto = new Moto ();


        EjecutaAcelerar(coche);
        EjecutaAcelerar(moto);

    }

    public static void EjecutaAcelerar (Vehiculo vehiculo) {
        vehiculo.Acelerar(15);

    }
}

interface Vehiculo {
    int variables = 0;
    void Acelerar (int cuantaVelocidad);
    void Frenar (int cuantaVelocidad);
        }

class Coche implements Vehiculo {
    public void Acelerar(int cuantaVelocidad) {
        System.out.println("Coche() -> Acelerar()");
            }

    public void Frenar (int cuantaVelocidad) {
        System.out.println("Coche() -> Frenar()");

    }

}

class Moto implements Vehiculo {
    public void Acelerar(int cuantaVelocidad) {
        System.out.println("moto() -> Acelerar()");
    }

    public void Frenar(int cuantaVelocidad) {
        System.out.println("moto() -> Frenar()");
    }
}



------

PARAMETROS QUE PASAMOS A UNA FUNCION:
    PASO POR VALOR: consiste en que cuando llamo a una funcion, copio los valores en memoria y se los doy

FUNCION SUMA (INT A, INT B) {
    DEVUELVE A + B
}

VAR VALA= 5;
VAR VALB =10;
SUMA (VAL1,VALB)  

en este caso se dice que cuando se llama a la funcion, en los parametros, los nombres de las variables copian el valor asignado en memoria. se dice que es copia de los valores, xq los originales no se cambian. 
los copian en una zona de memoria distinta, pero los valores originales no se modifican. consumo el doble de memoria, por lo tanto no me sirve cuando tengo valores muy pesados en memoria. 

public static void main(String[] args) {
        int valA = 5;
        int valB = 10;

        suma(valA, valB);
        System.out.println(valA);
        System.out.println(valB);
    }

    public static int suma (int a, int b) {  /en este caso, los valores de valA y valB se copian en las variables a y b de suma
        return a + b;
    }


PASO POR REFERENCIA:
tengo mis dos valores, y les digo que va a tener que trabajar la funcion con la direccion de memoria de esas variables. en lugar de copiar los valores, manipula los valores desde el mismo lugar de memoria.

en java, cuando el parametro es un objeto, estamos haciendo un paso por referencia, xq le pasamos la referencia del objeto. a diferencia del anterior, se necesita un parametro del tipo coche, se refiere a un objeto. 

public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();

        cocheChanger(coche); / aca hace la funcion en el main, con la funcion definida anteriormente y con el parametro coche

    }

    public static void cocheChanger (Coche coche) { / aca a la funcion en el parametro le pone una variable / objeto, o sea referencia ese valor 
        coche.velocidad += 50;  / aca seria el valor de la variable velocidad definida antes 0, sumandole 50 y que sea el resultado de cocheChanger
    }
}


public class Main {

    public static void main(String[] args) {
        Coche coche = new Coche();

        cocheChanger(coche);
        cocheChanger(coche);

        System.out.println(coche.velocidad);

    }

    public static void cocheChanger (Coche coche) {
        coche.velocidad += coche.velocidad + 50;
    }
}
cambio por referencia manipula la memoria de los parametros que le paso, ese valor luego permanece cambiado. 

RECURSIVIDAD:
una funcion/ metodo se va a llamar a si mismo, varias veces. 

FUNCION SUMA (INT A, INT B) {
    VAR TEMP = A + B
    SUMA (A, TEMP)
}
vuelve a invocar a la misma funcion, con el primer parametro y con un segundo como la variable temp de resultado. si no se controla la funcion recursiva, hay que tener cuidado xq puede dañar elprograma. hay que saber cuando detenerla. 

SI TEMP ES MAYOR A 15
    PARA!

    SUMA (A, TEMP)

ej mas tipico: el factorial de un numero. 
ejemplo de factorial recursivo en java, se usa este xq es mas facil y se invoca solo

public static int factorial (int numero) {
        int resultado;
        if (numero == 1) {
            return 1;
        }
        resultado = factorial(numero -1) * numero;
        return resultado;
    }

ej de forma no recursiva

 public static int factorialNR (int numero ) {
        int temp;
        int resultado = 1;
        
        for (temp = 1; temp <= numero; temp++) {
            resultado = resultado * temp;
        }
        return resultado;
    }


public static int factorial (int numero) {
        int resultado;

        if (numero == 1) {
            return 1;
        }
        resultado = factorial(numero -1) * numero;
        System.out.println(resultado);
        return resultado;
    }

    public static int factorialNR (int numero ) {
        int temp;
        int resultado = 1;

        for (temp = 1; temp <= numero; temp++) {
            resultado = resultado * temp;
        }
        System.out.println(resultado);
        return resultado;
    }

LENGUAJES COMPILADOS E INTERPRETADOS:
un compilador agarra una secuencia de caracteres/ fichero de codigo y lo convierte en otra cosa. una especie de traductor. agarra una entrada y la convierte en codigo maquina u otro lenguaje. 
tipos:
    GENERAN CODIGO MAQUINA
    GENERAN REPRESENTACION INTERMEDIA
se diferencian por el objetivo final.

un lenguaje compilado se compila a codigo maquina, un lenguaje interpretado no, se compila a otra cosa. 

CODIGO FUENTE -> [AQUI TRABAJA EL COMPILADOR] -> CODIGO FINAL 

VAR VARIABLE = 10;

primero tiene el analizador lexico, y genera el token. analiza cada letra del codigo fuente y va generando el token. define cada una de las letras analizandola. 
despues el compilador avanza, y va juntando los token para seguir leyendo. 

VAR -> "PALABRA RESERVADA VAR" (COMO IF, WHILE, DO, STATIC)
VARIABLE -> "IDENTIFICADOR"
= -> "SIMBOLO DE ASIGNACION"
10 -> "NUMERO_ENTERO"

esto es analizador lexico y token. 
cuando ya tiene todo el analisis, pasa a la siguiente fase: analisis sintactico.
analiza si tiene coherencia. 
 VAR VARIABLE =; (esto no tendria sentido, faltaria el numero o la variable) (esto hace el analisis sintactico, si tiene sentido lo que escribimos)
 if (numero > 10) {...}
 1.IF
 2. ABRE_PARENTESIS
 3. CONDICION
 4. CIERRA_PARENTESIS
 5. ABRIR LLAVE
 6. EXPRESIONES
 7. CIERRA LLAVE

 esto ya tendria grabado el analisis sintactico, a modo de ejemplo. 
luego de analizar, y da todo ok, genera un codigo intermedio (que no es el final). 
este codigo intermedio, es de mas bajo nivel, que sea mas facil de leer, y por si lo necesito a futuro, simplifica el lenguaje humano a algo que esta mejor representado y que pueda manipular mejor el compilador. 
aca se genera una estructura de datos llamada 
ABSTRACT SYNTAX TREE (arbol sintactico abstracto) representa todo el codigo nuestro pero a nivel de estructura de datos. 

FASE OPTIMIZACION DEL CODIGO INTERMEDIO: generan un codigo mas optimo que el escrito, o eliminar codigo redundante. 
Var variable = 3;
if (variable ==0) {
    acciones;
}
(podrian eliminar este codigo xq se dan cuenta que jamas ocurre, ya que la variable es 3 y ese if funciona con variable igual a 0)
tambien determina que es mas costoso de hacer a nivel computacional, para cambiar algunos codigos por ej con los for, hace "unroll loops".

FASE DE GENERACION DE CODIGO: aca es donde vemos los resultados. aca es donde genera codigo maquina o codigo para ser interpretado. 
FINALIZA COMPILADOR.

TIPOS DE LENGUAJES: 
LENGUAJE COMPILADO: se compila a codigo maquina y por lo tanto se ejecuta en nuestra compu a traves del sistema operativo. 
    C
    C++
    RUST
    GO
la diferencia con los interpretados, es que, no son ejecutados directamente por el sistema operativo, se ejecuta a traves de una maquina virtual o interprete. no se ejecutan nativamente en el procesador. 

    JAVA (todo lo que hicimos con java se ejecuto con una maquina virtual llamada JVM o Java Virtual Machine) en este caso lee un "BYTECODE", codigo para ser interpretado. 

    BYTECODE -> JVM -> RESULTADO FINAL 

suponemos C: CODIGO COMPILADO 
EXIT (0);
MOV AX, 4 Ch
INT 21h
    66 B8 4C 00 CD 21 (esto en binario, no hexadecimal)

SUPONEMOS CODIGO INTERPRETADO:

EXIT (0);
    CALL EXIT (aca lee el interprete y ejecuta lo siguiente )
    -> EJECUTAR SALIR DE LA APLICACION 

    interpretados mas utilizados:
    JAVA
    PYTHON
    PHP
    DART
    JAVASCRIPT
    RUBY

LENGUAJES COMPILADOS E INTERPRETADOS:
    C# 
    aca se genera un codigo intermedio, MSIL (Microsoft Intermediate Language) y se interpreta. pero el interprete, para ejecutarlo, decide en algunas partes compilar para hacer mas eficiente el codigo. 
    a esta tecnica se llama JIT (Just In Time) o JIT compiler. 
    
    
    un lenguaje compilado siempre va a ser mas rapido que un interpretado, xq el interpretado necesita un programa interprete. 
    los emuladores son compiladores. 
    los lenguajes interpretados son mucho mas faciles de depurar. 

otra ventaja del lenguaje interpretado es que una vez que lo escribis en interprete lo podes ejecutar en cualquier plataforma, ya que lleva su maquina virtual para ejecutar. 
el compilado no, hay que tener el codigo maquina para cada procesador. en este caso hay que hacer el generador de codigo maquina, para cada una de las plataformas. 