ruta de aprendizaje de java:
java SE (standar edition)
Java avanzada (spring)
es multiple paradigma, de alto nivel, facil de usar, es uno de los mas populares


CALCULADORA NERDEARLA 

https://docs.google.com/spreadsheets/d/1ceRosaOf8QgYv9bPlvpqxlvLddO2mtttDTLrEmiM-_M/htmlview?pru=AAABgpJm0Zo*E_AntloQZ-Kz1KNZIBL8MQ#

TABLA DE REFERENCIA DE SUELDOS

https://www.cpciba.org.ar/honorarios

ENCUESTA SALARIAL SYSARMIN

https://docs.google.com/spreadsheets/d/1h7VSFV2xkbgUi3kmJMVzCtX3RajwkzqdIyQkOsyathw/edit#gid=765652237

TABLA PERIODICA DE DEVOPS

https://digital.ai/devops-tools-periodic-table


FUNCIONES:

package com.example.funciones;

/**
 * Crear una funcion que reciba un precio y devuelva el precio con el IVA incluido
 */
public class Funciones {

    static double getPrice() {
        return 100.99;
    }


    /**
     * void indica que no devuelve nada
     */
    static void showMenu(){
        System.out.println("Bienvenidos al E-commerce de zapatillas:");
        System.out.println("1 - Ver zapatillas");
        System.out.println("2 - Comprar zapatilla");
        System.out.println("3 - Salir");
    }

    static String getMenu(){
        System.out.println("Imprimiendo texto prueba");
        return "Bienvenidos al E-commerce de zapatillas: \n 1 - Ver zapatillas....";
    }

    public static void main(String[] args) {

        // opcion 1: funcion sin parámetros y sin tipo de retorno
//         showMenu();
//         showMenu();

        // opcion 2: funcion sin parámetros y con tipo de retorno
        String menu = getMenu();
        System.out.println(menu);
        System.out.println(getMenu());

        double price = getPrice();
        System.out.println(price);

        // opcion 3:
        // funcion con parametros y sin tipo de retorno
        imprimirSaludoBuenosDias("OpenBootcamp");

        // opcion4:
        // funcion con parámetros y con tipo de retorno
        String nombre = "Alan";
        String apellido = "Sastre";
        String saludo = obtenerSaludo(nombre, apellido);
        System.out.println(saludo);

        int resultadoSuma = suma(50, 200);
    }

    static int suma(int numero1, int numero2){
        return numero1 + numero2;
    }


    static String obtenerSaludo(String nombre, String apellido){
        return "Buenas tardes " + nombre + " " + apellido;
    }


    static void imprimirSaludoBuenosDias(String nombre){
        System.out.println("Buenas tardes " + nombre);
    }

}

package com.example.funciones;

/**
 * Sobrecarga permite duplicar un método siempre y cuando tengan diferente numero/tipo parametros.
 */
public class Sobrecarga {

    public static void main(String[] args) {

    }

    static double suma(double numero1, double numero2){
        return numero1 + numero2;
    }

    static int suma(int numero1, int numero2){
        return numero1 + numero2;
    }

    static int suma(int numero1, int numero2, int numero3){
        return numero1 + numero2 + numero3;
    }
}

ESTRUCTURAS DE CONTROL:
IF:
package com.estructurasdecontrol;

public class If {
    public static void main(String[] args) {
        int edad = 19;
        boolean esMayor = edad >= 18; // false

        if(esMayor){
            System.out.println("Es mayor de edad");
        }

        if(edad >= 18){
            System.out.println("Es mayor de edad");
        }
    }
}

IF ELSE:

package com.estructurasdecontrol;

public class IfElse {
    public static void main(String[] args) {
        int edad = 16;

        if (edad >= 18) { // si true entra aquí
            System.out.println("Es mayor de edad");
        } else { // si false entra aquí
            System.out.println("Es menor de edad");
        }
    }
}

IF ELSE IF:

package com.estructurasdecontrol;

public class IfElseIf {
    public static void main(String[] args) {
        String dia = "DiaNostro";

        // ejemplos comparar
        boolean resultadoCompararNum = 5 == 5; // si comparo numeros uso ==
        boolean resultado = dia.equals("Martes"); //uso esta funcion para comparar string.

        // if else if

        if (dia.equals("Lunes")) {
            System.out.println("Animo con la semana champions");

        } else if (dia.equals("Martes")) {
            System.out.println("Martes con M de Me besas");

        } else if (dia.equals("Miercoles")) {
            System.out.println("Miercoles con M de Me besas");

        } else if (dia.equals("Jueves")) {
            System.out.println("Ya es juernes");

        } else if (dia.equals("Viernes")) {
            System.out.println("Nos fuimos!");

        } else if (dia.equals("Sabado")) {
            System.out.println("Nos murimos!");

        } else if (dia.equals("Domingo")) {
            System.out.println("Depresión");
        } else {
            System.out.println("El día introducido no es un día válido.");
        }


    }
    }

SWITCH:
parecido al if else if. 
package com.estructurasdecontrol;

public class Switch {
    public static void main(String[] args) {
        String dia = "Martes";

        switch(dia){
            case "Lunes":
                System.out.println("Hoy es Lunes!! Animo!!");
                break;
            case "Martes":
                System.out.println("Hoy es Martes!! Animo!!");
                break;
            case "Miercoles":
                System.out.println("Hoy es Miercoles!! Animo!!");
                break;
            case "Jueves":
                System.out.println("Hoy es Jueves!! Animo!!");
                break;
            case "Viernes":
                System.out.println("Hoy es Viernes!! Animo!!");
                break;
            case "Sabado":
                System.out.println("Hoy es Sabado!! Animo!!");
                break;
            case "Domingo":
                System.out.println("Hoy es Domingo!! Animo!!");
                break;
            default:
                System.out.println("No es un día válido");

        }

    }
    }


REPETITIVAS:
FOR PARA CONCATENAR TEXTO:
package com.estructurasdecontrol.repetitivas;

public class ConcatenarTexto {
    public static void main(String[] args) {

        String[] nombres = {"Pepito", "Juanit", "eveready"};

        for(String nombre : nombres){

            }
        }
    }

 Esto lo puedo usar para concatenar textos como quiera, para no hacer tantos prints. 

 FOR:

 package com.estructurasdecontrol.repetitivas;

public class For {
    public static void main(String[] args) {
        for(int i = 0; i < 20; i++){
            // System.out.println("El valor de i es: " + i );
            // System.out.println("Hola mundo");
        }
                            // 0        1           2
        String[] nombres = {"Pepe", "Juanito", "Ruperta"}; // length 3
        for(int i = 0; i < nombres.length; i++){
            System.out.println(nombres[i]);
        }
puedo usarlo para recorrer arrays de nombres y de numeros. 
        int suma = 0;
        int[] numeros = {5, 7, 8}; // length 3
        for(int i = 0; i < numeros.length; i++){
            // suma = suma + numeros[i];
            suma += numeros[i];
        }


    }
    }

generalmente el for, se usa para iterar sobre un array.    

FOR EACH:

package com.estructurasdecontrol.repetitivas;

public class ForEach {
    public static void main(String[] args) {
        String[] nombres = {"Pepe", "Juanito", "Ruperta"};

        for(String nombre : nombres){ //estructura del for each
            System.out.println(nombre);
        }

        int[] numeros = {5, 10 , 15};

        int suma = 0;
        for(int numero : numeros){ //estructura de for each para numeros. aca no se pone indice i=0;
            suma += numero;  //simplificacion de suma = suma + numero (i);
        }
        System.out.println(suma);

    }
    }

WHILE: bucle indeterminado

package com.estructurasdecontrol.repetitivas;

/**
 * Crear un bucle que permita concatenar textos y imprima el resultado final por consola.
 * Concatenar nombres
 * Los textos pueden venir de un array String
 * String[] nombres = {"", "", "", ""};
 */
public class While {

    public static void main(String[] args) {

        int contador = 0;

        while(contador < 10){
            String nombre = "Prueba";
            contador++;
            if (contador == 5){
                // break; se usa pàra romper un bucle
                continue;
            }
            System.out.println("Valor de contador  " + contador);
        }
        // Variable nombre está fuera del ámbito del que se creó
        // System.out.println(nombre);
    }
}

CONCEPTOS DE CLASES Y OBJETOS:
se emulan los objetos de la realidad en el codigo fuente.

package poo.clases;

public class Vehiculo {
    //aca adentro es donde se explica la estructura que va a tener la clase y a partir de ella crear objetos

    // ESTRUCTURA DE LOS OBJETOS
    // 1. atributos
    String fabricante;
    String modelo;
    double cc;  // si lo pongo con mayuscula la primera, es una clase tipo envoltorio y me permite que pueda tener valores nulos, si no lo pongo directamente double como dato primitivo.
    int year;
    boolean sport;
    int speed;


    //2. constructores: son metodos especiales que me permiten construir los objetos a partir de esta plantilla (clase)
    public Vehiculo () { //siempre es publico, va con el nombre de la clase, puedo ponerlo vacio para que me permita crear objetos sin atributos.

    }
    //puedo utilizar la sobrecarga para crear un constructor igual que el anterior pero cambiando los parametros
    public Vehiculo (String fabricante, String modelo, double cc, int year, boolean sport) {
        this.fabricante = fabricante; // se asigna desde el constructor al atributo, para invocar este constructor desde afuera.
        this.modelo = modelo; //hace referencia al atributo que esta dentro de la clase = parametro del constructor
        this.cc = cc;
        this.year = year;
        this.sport = sport;
        this.speed = 0;  //asumir que la velocidad del coche es 0
    }
    //puedo crear el mismo constructor con sobrecarga con menos parametros
    public Vehiculo (String fabricante, String modelo) {
        this.fabricante = fabricante;
        this.modelo = modelo;
    }

    public Vehiculo(String fabricante, int year) {  //puedo crear ese constructor con generate en click derecho
        this.fabricante = fabricante;
        this.year = year;
    }

    // 3. metodos (comportamiento): puedo crear funciones para ese vehiculo, para modificar su comportamiento
    public void acelerar (int quantity) {
        this.speed += quantity;
    }

porque se haria encapsulacion de atributos con private, para proteger la manera en que esos atributos se cambiando
se puede hacer tambien composicion, que es relacionar clases unas con otras, para que una clase no sea tan pesada
concepto de herencia
uso la palabra reservada protected en los atributos para poder usarlos en herencia desde otra clase.
esto me permite desde cualquier clase poder acceder a los atributos de vehiculo.
con el metodo super yo puedo acceder a un constructor de la clase superior. 
project ob-poo en Bootcamp java.
no se puede heredar de dos clases, es decir de clase padre y madre

clase abstracta quiere decir que no puede ser instanciada. 

package poo.clases;

import poo.herencia.Camion;
import poo.herencia.Coche;
import poo.herencia.Motocicleta;

public class Main {
    public static void main(String[] args) {   //static me permite que un atributo o metodo pertenece a la clase, y lo puedo ejecutar

        //Clase identificador = new Clase();  asi se crearia un objeto de una clase, una llamada al constructor

        // crear un objeto utilizando el constructor vacio
        Vehiculo toyotaPrius = new Vehiculo();

        // crear un objeto utilizando el constructor con parametros. ctrl p para ver los parametros

        Motor motorGTI = new Motor("GTI",190,459.0,6);
        //creo este objeto motor para poder pasarselo al objeto vehiculo como nuevo parametro

        Vehiculo fordMondeo = new Vehiculo("Ford", "Mondeo",2.1,2010,false,0,motorGTI);
        System.out.println(fordMondeo.fabricante);
        System.out.println(fordMondeo.year);
        System.out.println(fordMondeo.speed); // 0
        fordMondeo.acelerar(50);
        System.out.println(fordMondeo.speed); //50

        //HERENCIA
        Motocicleta kawasakiNinja = new Motocicleta ();
        kawasakiNinja.fabricante ="Kawasaki";

        System.out.println("Fin de programa");


        // POLIMORFISMO a partir de una forma como ser vehiculo, se puede comportar como las distintas clases, de distintas formas.


        Vehiculo vehiculo;
        vehiculo = new Motocicleta();
        vehiculo.acelerar(50);

        vehiculo = new Coche();
        vehiculo.acelerar(50);

        vehiculo = new Camion();
        vehiculo.acelerar(50);
        
        //CLASES ABSTRACTAS: no se pueden instanciar, solo instancian (crear objeto) las clases hijas. 

programacion generica es la programacion que permite que los metodos trabajan con distintos tipos de datos.

ESTRUCTURA DE LAS INTERFACES:
la interfaz sirve de abstraccion, es poder hacer que un codigo que depende de otro codigo no este acoplado. 
define una serie de metodos a realizar pero no los hace, si no que una clase los implementa
si quiero que se muestren los datos de un objeto en la consola, y no la referencia en memoria
creo que el metodo tostring
generalmente le agrego un metodo tostring a las clases para que muestre los atributos

seria un intermediario entre el main, y las versiones de clase, para no tener que cambiar el codigo
proporcionan una manera comun de hacer algo, que luego cada clase proporciona su implementacion. 
esto me da BAJO ACOPLAMIENTO CON LAS IMPLEMENTACIONES. 
las interfaces solo declaran metodos, pero no los implementan 
se usa la palabra implements.
la ventaja es que podemos implementar multiples interfaces

public class EmpleadoCRUDExcel implements EmpleadoCRUD, EmpleadoReader{

REFACTORING: rehacer el codigo manteniendo la manera funcional pero que el codigo sea mucho mas facil, 
mantenible, con menor complejidad, legible. etc. 
tecnicas o metodos que se usa para reducir la complejidad del codigo. 
deuda tecnica es cuando el codigo hace lo que tiene que hacer pero de una manera compleja. 
es decir, se mejora el codigo, se hace mas facil de leer. 

consolidar un condicional:
boton derecho, extract method. 
agrupar condiciones usando AND  (&&) o OR (||)

eliminar las duplicaciones de codigo:
se puede sacar codigo de dentro de alguna condicion repetido afuera. 

extraer clases:
sacar atributos de una clase, y crear otra clase para esos atributos que saque.
para no tenes todos los atributos en una misma clase, si no, simplificar y sacar.

extract method:
boton derecho, extract method. 
los codigos se pueden desglosar por pasos, para que sea mas facil de modificar a futuro

Magic numbers:
usar una variable global para asignar a un numero. un numero magico es el numero que se mete en el codigo
por si en el futuro quiero cambiar ese numero, solo lo cambio en la variable. 
se usa private static final (tipo de dato) y nombre de constante. 
se reemplaza el numero por la constante. se nombran con MAYUSCULAS_SEPARADAS_POR_BARRA
si son variables constantes de numeros. 

removeassign:
funcion pura es mantener intacto los valores de las variables que me pasaron,
y generar otra variable para obtener ese resultado, sin modificar los primeros parametros. 

replace method:
crear una clase para meterle un metodo complejo, y asi no tener clases cargadas. 


DATOS AVANZADOS EN JAVA:
STRING:
public class Main {
    public static void main(String[] args) {
        String cadena = "Mensaje de TEXTO";

        int candenaLen= cadena.length(); //saber la longitud de mi string
        System.out.println("La longitud de mi cadena es de: " + candenaLen);

        //convertir cadena a mayusculas o minusculas

        String cadenaMinus = cadena.toLowerCase();
        System.out.println("La cadena ahora es: "+ cadenaMinus);

        String cadenaMayus = cadena.toUpperCase();
        System.out.println("La cadena ahora es: "+ cadenaMayus);


public class Main {
    public static void main(String[] args) {
        String cadena = "Mensaje de TEXTO";

        //para determinar si una cadena de texto empieza por una palabra o no

        boolean resultado = cadena.startsWith("Men");
        if (resultado) {
            System.out.println("Empieza por lo que estoy buscando");
        } else {
            System.out.println("no empieza por lo que quiero");
        }

 boolean resultado2 = cadena.endsWith("o");
        if (resultado2) {
            System.out.println("termina por lo que estoy buscando");
        } else {
            System.out.println("no termina por lo que quiero");
        }

public class Main {
    public static void main(String[] args) {
        String cadena = "Mensaje de TEXTO";
        //CHAR para saber segun la posicion en la cadena, que caracter quiero recuperar

        char letra = cadena.charAt(0);
        System.out.println("Caracter es : "+ letra);

        //recorrer cadenas de textos

        for (int i = 0; i < cadena.length(); i++) {
            System.out.println("caracter actual : " + cadena.charAt(i));
        }


ARRAYS:

public class Main {
    public static void main(String[] args) {

        //arreglo o arrays de enteros
        int arrayUno[] = new int [5]; // esto es un array creado que indica el numero maximo de elementos 
        arrayUno[0] = 1;  //asi voy asignando valores al array 
        arrayUno[1] = 2;
        arrayUno[2] = 3;
        arrayUno[3] = 4;
        arrayUno[4] = 5;
        
        for (int i : arrayUno) {
            System.out.println(i);
        }


        //si se que elementos va a tener el array uso esta forma

        int arrayUnov2 [] = {1, 2, 3, 4, 5};

        for (int i : arrayUnov2) {
            System.out.println(i);
        }

 // formas de recorrer un array 
        // forma corta o for each for variable temporal (String nombre: nombres
        //aca tengo los valores, y accedo
        for (String nombre : nombres) {
            System.out.println("Nombre actual: " + nombre);
        }

//forma larga de recorrer un array. 
        //en esta forma , tengo la posicion pero no el valor, y para tener el valor tengo que acceder a traves de su posicion
        
        for (int i = 0; i < nombres.length; i++) {
            System.out.println("Nombre actual: " + nombres[i]); 
        }

 String ultimoNombre = "";

        //forma larga de recorrer un array.
        //en esta forma , tengo la posicion pero no el valor, y para tener el valor tengo que acceder a traves de su posicion
        // aca recorro el array y voy posicion por posicion
        for (int i = 0; i < nombres.length; i++) {
            System.out.println("Nombre actual: " + nombres[i] + " en posicion " + i);
            ultimoNombre = nombres[i]; // a cada iteracion del bucle for, a la variable que itere le va a ir asignando la variable actual
            //a ultimo hombre

        }

 //atravesar un array con un while
        
        int contador =0;
        while (contador < nombres.length) {
            System.out.println("Nombre actual: " + nombres[contador] + " en posicion " + contador);
            contador++;
        }
ARRAYS BIDIMENSIONALES Y COMO RECORRERLOS:

public class Main {
    public static void main(String[] args) {
        //pueden ser bidimensionales. se usan para hacer asociaciones y los tridimensionales para matrices matematicas.

        int arrayBidi[][] = new int[2][4]; //primer elemento es filas, segundo es columnas
        arrayBidi[0][0] = 1;
        arrayBidi[0][1] = 2;
        arrayBidi[0][2] = 3;
        arrayBidi[0][3] = 4;
        //asi es para rellenar numeros de filas y columnas
        arrayBidi[1][0] = 10;
        arrayBidi[1][1] = 20;
        arrayBidi[1][2] = 30;
        arrayBidi[1][3] = 40;
        //para recorrerlo. por cada dimension tengo que meter un for

        for (int i = 0; i < arrayBidi.length; i++) {
            System.out.println("Valor de i: " + i);

            for (int j = 0; j < arrayBidi[i].length; j++) {  //j para el segundo for, k tercer for
                System.out.println("Estoy en i = " + i + "j = " + j);
                System.out.println(arrayBidi[i][j]); //quiero ver el valor de cada posicion en fila y columna
            }
        }

//puedo cambiar los elementos de un array, lo que no puedo hacer es agregarlos.
        String nombres [] = {"Pepe", "Juan"};
        nombres [0] = "Victor";
        nombres [1] = "Paco";

        for (String nombre:nombres) {  //recorrer para imprimir el array
            System.out.println((nombre));
        }

VECTORES:

import java.util.Vector;

public class Main {
    public static void main(String[] args) {
        // VECTORES
        //son como arrays, pero no se les da tamaño inicial y final si queremos, se ajusta automaticamente
        Vector <Integer> vector = new Vector();
        //se usa metodo para llenarlo
        vector.add(1);
        vector.add(2);
        vector.add(3);
        System.out.println("Datos del vector: " + vector);

        //metodo que permite eliminar indices ej posicion 2. siempre con remove se refiere a la posicion 

        vector.remove(2);
        System.out.println("Datos del vector: " + vector);
        
        //tienen dos propiedades: tamaño y capacidad. 

        System.out.println("Vector tamaño: " + vector.size() + " y capacidad: " + vector.capacity());

        //tienen dos propiedades: tamaño y capacidad.
        //tamaño son los elementos que le voy agregando
        //capacidad es la capacidad que tiene el array por debajo subyacente
        //la capacidad se actualiza, y se crean nuevos arrays por debajo para mantener la capacidad. 
        //se llaman array dinamicos tambien
        

        System.out.println("Vector tamaño: " + vector.size() + " y capacidad: " + vector.capacity());
        
        //beneficio xq crece automaticamente
        //cuando la capacidad tiene que aumentar, se produce una copia, xq se crea array nuevo y se tienen que copiar los datos viejos
        
Vector <Integer> vector = new Vector(50); // se le puede poner capacidad inicial Vector (50)
Vector <Integer> vector = new Vector(50,15); // se le puede poner el incremento en capacidad. 
//crea un array nuevo de solo 15 elementos mas


import java.util.Vector;


public class Main {
    public static void main(String[] args) {
        // VECTORES
        //son como arrays, pero no se les da tamaño inicial y final si queremos, se ajusta automaticamente
        Vector <Integer> vector = new Vector(1 ,15);
        //se usa metodo para llenarlo
        vector.add(1);
        vector.add(2);
        vector.add(3);

        // 10 ints
        System.out.println("Datos del vector: " + vector);


        //tienen dos propiedades: tamaño y capacidad.
        //tamaño son los elementos que le voy agregando
        //capacidad es la capacidad que tiene el array por debajo subyacente
        //la capacidad se actualiza, y se crean nuevos arrays por debajo para mantener la capacidad.
        //se llaman array dinamicos tambien


        System.out.println("Vector tamaño: " + vector.size() + " y capacidad: " + vector.capacity());

        //beneficio xq crece automaticamente
        //cuando la capacidad tiene que aumentar, se produce una copia, xq se crea array nuevo y se tienen que copiar los datos viejos
        // se duplica el consumo de memoria


// se pueden comparar los vectores

        Vector<Integer> vector2 = new Vector();
        vector2.add(1);
        vector2.add(2);

        boolean resultado = vector.equals(vector2); //primero vector original, luego metodo equals, luego (vector a comparar)
        System.out.println("Son iguales?: " + resultado);

 // se puede recorrer

        for (int i : vector) {  //forma corta, recorro al contenido pero no a la posicion
            System.out.println("Valor actual en vector: " + i);
        }

        //forma larga de recorrer
        //no puedo acceder a vector [i]


        for (int i =0; i < vector.size(); i++) {
            System.out.println("Valor es: " + vector.get(i) + " en posicion: " + i); // con vector.get(i) accedo a la posicion
        }

 for (int i =0; i < vector.size(); i++) {
            if ( i % 2 == 0 ) {
                vector.remove(i);
                continue;  
            }
            System.out.println("Valor es: " + vector.get(i) + " en posicion: " + i); // con vector.get(i) accedo a la posicion
        }
        // una vez que elimino un elemento de un vector, esa posicion queda inutilizada, es inaccesible. por eso me daba error
        // tuve que poner continue xq despues, el codigo seguia y yo le ponia vector.get(i). 

 System.out.println(vector.get(3));  //para que me muestre el valor de la posicion 3
        //si ahora hago un remove
        vector.remove(3);
        System.out.println(vector.get(3)); //si quiero volver a imprimirlo, me da error, xq ya no existe ese valor. 



System.out.println("Capacidad de vector: " + vector.capacity() + " Tamaño: " + vector.size());
        //pueden crecer automaticamente pero puedo determinar que decrescan con un metodo, para achicarlo
        //un metodo que reduce la capacidad del vector hasta su tamaño para liberar memoria
        vector.trimToSize();
        System.out.println("Capacidad de vector: " + vector.capacity() + " Tamaño: " + vector.size());
        
        //son arrays dinamicos, crecen automaticamente y decrecen hasta el tamaño de sus elementos, crecer y decrecerlos no es 
        //barato computacionalmente hablando. 
        //capacidad inicial proximo a lo que necesitamos, y tamaños ni muy grandes ni pequeños. 

ARRAY LIST:
import java.util.ArrayList;
import java.util.Vector;

// ARRAY LIST
public class Main {
    public static void main(String[] args) {
        ArrayList <String> lista = new ArrayList<String>(); // se declara con el tipo de dato, new , (tipo de dato)
        lista.add("ElementoA");
        lista.add("ElementoB");
        lista.add("ElementoC");

        //implementacion de interface lista
        //diferencia con el vectores: los array list no tienen capacity, es automatica.
        //CapacidadVector = CapacidadVector * 2, mientras que el vector crecia el doble
        //CapacidadArrayList = CapacidadArrayList + (CapacidadArrayList * 0.5)
        //esto quiere decir que aumenta el 50% la capacidad del array list, despues funcionan igual

        System.out.println("Contenido "+ lista); //la salida es igual que la lista
        lista.remove("ElementoB");
        System.out.println("Contenido "+ lista);

        //los array list no se pueden modificar de forma concurrente dos posiciones, es inseguro cuando se hacen estas operaciones
        //no es track safe, un vector si lo es
        lista.remove(2);
        //para recorrer
        for (String nombre : lista) {
            System.out.println(nombre);
        }

        for (int i=0; i < lista.size(); i++) {
            System.out.println(lista.get(i)); //tengo que usar metodo get para acceder a esa posicion del array
        }
        lista.remove(2);

PARA CONVERTIR UN ARRAY LIST EN ARRAY
import java.util.ArrayList;
import java.util.Vector;

// ARRAY LIST
public class Main {
    public static void main(String[] args) {
        ArrayList <String> lista = new ArrayList<String>(); // se declara con el tipo de dato, new , (tipo de dato)
        lista.add("ElementoA");
        lista.add("ElementoB");
        lista.add("ElementoC");

        //se puede convertir el array list en un array

        String array [] = new String[lista.size()];  //pongo el tamaño xq lo se, no se el contenido
        //lo convierto recorriendolo pero con la forma larga del for, xq necesito el indice y las posiciones
        for (int i = 0; i < lista.size(); i++) {
            array[i] = lista.get(i);  //asi voy rellenando el array con los elementos de la lista
        }
        //para imprimirlo
        for (String elemento:array) {
            System.out.println(elemento);
        }
        
 //se puede convertir a array y recorrer al mismo tiempo, usando la clase object
        //es la clase padre de java 

        for (Object arrayObjeto :lista.toArray()) { //creo la variable de clase object, y le asigno la lista.toarray.
            System.out.println(arrayObjeto.toString());
        }


//Dos tipos de listas principales, las array list y las linked list.
        //diferencia: operan igual, se declaran igual
        //depende del programa uso uno u otro
        //un array list usa un array de forma subyacente para almacenar datos, en cambio la linked list usa el tipo lista
        //doblemente enlazada. 
        //el array es mas rapido para almacenar y buscar datos. la linked list es mas rapida para modificar datos
        //linked list uso la interface list y la interface beke. se usa para implementar colas (listas que meten datos por un sitio
        // y se saca por otro. LIPO y FIPO. 
        //se puede crear una linked list partiendo de un array list 
        
                LinkedList<String> listaEnlazada = new LinkedList<String>(lista); //declara linked list. se le puede pasar como parametro el array
// BIG DECIMAL 

public class Main {
    public static void main(String[] args) {
        //clase dig decimal para obtener exactitud en cuentas de numeros
        BigDecimal valorA = new BigDecimal(0.1f);  //declaro valorA
        BigDecimal valorB = new BigDecimal(4f);  //declaro valorB para hacer cuenta

        BigDecimal resultadoMultiplicacion = valorA.multiply(valorB); //operadoror iginal.multiply  y despues operador sobre el cual opero. uso metodo multiply
        BigDecimal resultadoSuma = valorA.add(valorB);  // necesito variable resultado
        System.out.println("El resultado de la suma es de: " + resultadoSuma.toString());
        System.out.println("El resultado de la multiplicacion es de: " + resultadoMultiplicacion.toString());

        // se usa para ambito financiero


// MAPAS

 //MAPAS o array asociativo
        //es como un diccionario, donde tengo clave y valor (otro mapa, array,string,etc)
        //no se puede tener la clave duplicada

        HashMap <String, Integer> mapa = new HashMap<>(); //mapa de claves de texto, con valores de enteros
        mapa.put("clave1", 10);  //para agregar datos al mapa
        mapa.put("clave2", 20);
        mapa.put("clave3", 30);
        mapa.put("clave4", 40);

        System.out.println(mapa);

        //para imprimir una clave concreta
        System.out.println(mapa.get("clave1"));

        //sustituir valores en el mapa. si no existe, la crea

        mapa.put("clave3", 90);

        //forma coherente de reemplazar valor que existe. si no existe, no la crea a la clave

        mapa.replace("clave2", 50);

        System.out.println(mapa);
        
        //eliminar valores

        mapa.remove("clave1");
        System.out.println(mapa);
        
        //recorrer mapa
        
        for (Map.Entry elemento: mapa.entrySet()) {
            System.out.println("Elemento clave es: " + elemento.getKey());
            System.out.println("Elemento valor es: " + elemento.getValue());
            
        }

CONTROL DE ERRORES:

  un comportamiento no esperado en nuestro programa. tambien cuando lo diseño o escribo, no solo cuando ejecuto.
  1 tipo: error en tiempo de ejecucion: situacion en el programa que hace que el programa aborte. 
ej: dividir algun numero / 0. en este caso se produce error. 

2. error de compilacion: cuando falta algo en el codigo, tipo ej: ;  .  ( )
    error sintactico, que no cumplo con la sintaxis de java. 

3. error logico u humano: lo que yo le digo al programa que haga, esta mal dicho. la logica humana es mala. 
    Ej: temperatura alta que diga que haga frio. son los peores xq no me doy cuenta de ellos. 

Avisos: estan en problems, en el run del compilador, nos avisa posibles errores. 
    @SuppressWarnings ("rawtipes"
    se los puede pasar por altos, ignorar. 
    generalmente voy a tratar de resolver los warnings.

GESTION DE ERRORES:
cuando hay error de run time, se dispara una excepcion. 
se usa try. y se mete el codigo que quiero proteger.

 //GESTION DE ERRORES:
        Scanner scanner = new Scanner(System.in);
        System.out.println("Introduce dos numeros: ");
        
        int numeroA = scanner.nextInt();
        int numeroB = scanner.nextInt();
        
        try {
            int resultado = numeroA / numeroB;
            System.out.println("Resultado: " + resultado);
        } catch (Exception e) {  //esto es excepcion de todos los errores
            System.out.println("boom! Error: " + e.getClass());
        }  } finally {
            System.out.println("Finally");
        }


PUEDO GESTIONAR VARIAS EXCEPCIONES

try {
            int resultado = numeroA / numeroB;
            System.out.println("Resultado: " + resultado);
        } catch (ArithmeticException e) {
            System.out.println("boom! Error: " + e.getClass());
            int resultado = numeroA / 1;
        } catch (Exception e) {
            System.out.println("Estoy en una excepcion que no es arithmeticException");
             } finally {
            System.out.println("Finally");
        }
el try catch pase lo que pase, ejecuta el codigo que tenemos en el finally. 

se puede generar EXCEPCIONES
throw (genera excepcion) y throws (para declarar que una funcion devuelve excepciones)

import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            divide (4, 0);
        } catch (Exception e) {
            System.out.println("AAAA");
        }
    }

    public static int divide(int A, int B)  throws  ArithmeticException , IOException{
        int resultado = 0;
        try {
             resultado = A / B;
        } catch (ArithmeticException e) {
            throw new IOException();
        }
        return resultado;
    }
}

Se puede capturar excepciones, las puedo capturar en el primer metodo, pero tengo que arrojarlas
a la clase main, y capturar de nuevo con otro try.

INPUT / OUTPUT

obtener datos y generar datos, de multiples fuentes
Ej: leer un fichero

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class Main {
    public static void main(String[] args) {
        try { //tengo que meter en un try el fileInputStream xq si o si tiene que arrojar algo. aunque sea error
        InputStream fichero = new FileInputStream("C:\\Users\\Carolina\\Desktop\\BHPD 2022\\GFH\\NI 485 ETMP6290F1232.txt");

        try {
            byte[] datos = fichero.readAllBytes();

            for (byte dato: datos) {
                System.out.println((char)dato);
            }
        } catch (IOException e) {
            System.out.println("No puedo leer el fichero: " + e.getMessage());  //wapring de errores
        }

        } catch (FileNotFoundException e) {
            System.out.println("El programa da error: " + e.getMessage());
        }
    }
}

//a mi InputStream de nombre fichero le dije que va a operar con el fichero equipamiento....
//el FileInputStream me devuelve una secuencia de bytes. tengo que guardarlo en el tipo de datos acorde
//creo el array de tipo bytes datos, y leo el fichero con readAllBytes pero tengo que mterlo en un try catch
//me falta mostrar el dato. lo meto dentro del try de cuando lo leo. le pongo char xq quiero que me muestre texto, y no numeros de bytes


// puedo leerlo caracter por caracter con read, y int.
//si leo fichero por fichero es mas lento


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class Main {
    public static void main(String[] args) {
        try { //tengo que meter en un try el fileInputStream xq si o si tiene que arrojar algo. aunque sea error
        InputStream fichero = new FileInputStream("C:\\Users\\Carolina\\Desktop\\BHPD 2022\\GFH\\NI 485 ETMP6290F1232.txt");

        try {
            int dato = fichero.read(); //contiene el codigo numerico de lo que quiero leer
            while (dato != -1) { //el - 1 es cuando termina el fichero
                System.out.println((char)dato);  //convierto el dato en char
                dato =fichero.read(); //importante actualizar la variable dato
            }


        } catch (IOException e) {
            System.out.println("No puedo leer el fichero: " + e.getMessage());  //wapring de errores
        }

        } catch (FileNotFoundException e) {
            System.out.println("El programa da error: " + e.getMessage());
        }
    }
}

puedo leer por partes 
try {
            byte datos [] = new byte[5];
            int dato = fichero.read(datos); //contiene el codigo numerico de lo que quiero leer
            while (dato != -1) { //el - 1 es cuando termina el fichero
                System.out.println(datos.toString()); //convierto el dato en char
                dato =fichero.read(); //importante actualizar la variable dato
            }


BUFFER

public class Main {
    public static void main(String[] args) {
        try { //tengo que meter en un try el fileInputStream xq si o si tiene que arrojar algo. aunque sea error
        InputStream fichero = new FileInputStream("C:\\Users\\Carolina\\Desktop\\BHPD 2022\\GFH\\NI 485 ETMP6290F1232.txt");
        BufferedInputStream ficheroBuffer = new BufferedInputStream(fichero); //hago el buffer con parametro de entrada el input
        try {

            int dato = fichero.read(); 
            while (dato != -1) { //el - 1 es cuando termina el fichero
                System.out.println((char)dato); //convierto el dato en char
                dato =ficheroBuffer.read(); //parcialmente en memoria y parcialmente no
            }

// mete en memoria un pedazo del arhivo y va leyendo de a poco, automaticamente 

import java.io.*;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        
        try {
            InputStream fichero2 = new FileInputStream("C:\\Users\\Carolina\\Desktop\\BHPD 2022\\GFH\\NI 485 ETMP6290F1232.txt");
            Scanner scanner = new Scanner(fichero2);
       

        //tengo que meter en un try el fileInputStream xq si o si tiene que arrojar algo. aunque sea error
        InputStream fichero = new FileInputStream("C:\\Users\\Carolina\\Desktop\\BHPD 2022\\GFH\\NI 485 ETMP6290F1232.txt");
        BufferedInputStream ficheroBuffer = new BufferedInputStream(fichero); //hago el buffer con parametro de entrada el input
        try {

            int dato = fichero.read();
            while (dato != -1) { //el - 1 es cuando termina el fichero
                System.out.println((char)dato); //convierto el dato en char
                dato =ficheroBuffer.read(); //parcialmente en memoria y parcialmente no
            }


        } catch (IOException e) {
            System.out.println("No puedo leer el fichero: " + e.getMessage());  //wapring de errores
        }

        } catch (FileNotFoundException e) {
            System.out.println("El programa da error: " + e.getMessage());
        }
    }
}

try {
           Scanner scanner = new Scanner(System.in);
            System.out.println("Mete dos numeros: ");
            int a = scanner.nextInt();  //esto mete cualquier cosa, si quiero que sea solo numero seria scanner.nextint();
            int b = scanner.nextInt();  //lee una entrada y busca enteros
            System.out.println("Enteros son: " + a +" " + b);

    
 try {
           Scanner scanner = new Scanner(System.in);
            System.out.println("Mete dos numeros: ");
            String a = scanner.next();  //por defecto, scanner.next devuelve string
            String b = scanner.next();
            System.out.println("Palabras son: " + a +" " + b);

METODO FLAG, que es ponerle un boolean y while para que pida scanners validos

public class Main {
    public static void main(String[] args) {

        try {
            Scanner scanner = new Scanner(System.in);

            boolean ok = false;
            do {
                System.out.println("Mete dos numeros: ");
                try {
                    int a = scanner.nextInt();
                    int b = scanner.nextInt();

                    ok = true;
                } catch (InputMismatchException e) {
                    System.out.println("Numeros invalidos");
                }
            } while (!ok);
        } catch (InputMismatchException e) {
            System.out.println("El programa da error: " + e.getMessage());
        }

        }
        }


        // me da bucle infinito, xq el scanner no se reinicia automaticamente. necesito hacer que vuelva al principio.
//hay que meter el scanner en el do while y resetearlo


 try {
            boolean ok = false;
            do {
                Scanner scanner = new Scanner(System.in);
                System.out.println("Mete dos numeros: ");
                scanner.reset();
                try {
                    int a = scanner.nextInt();
                    int b = scanner.nextInt();
                    System.out.println("Tus numeros ingresados son: " + a  + " y "+ b);

                    ok = true;
                } catch (InputMismatchException e) {
                    System.out.println("Numeros invalidos");

LEER UN FICHERO EN MEMORIA Y COPIARLO:
import java.io.*;
import java.util.InputMismatchException;
import java.util.Scanner;
//leer un fichero en memoria y luego copiarlo
public class Main {
    public static void main(String[] args) {
        try {
            InputStream in = new FileInputStream("C:\\Users\\Carolina\\Desktop\\BHPD 2022\\GFH\\NI 485 ETMP6290F1232.txt");
            byte[] datos = in.readAllBytes();

            PrintStream out = new PrintStream("destino.txt");
            out.write(datos);

        } catch ( Exception e ) {
            System.out.println("Excepcion: " + e.getMessage());

        }
    }
}

/* en consola
    ls : ve los ultimos movimientos
    cat (nombre el fichero) : veo el fichero en consola
    diff -u (nombre fichero copiado) (nuevo nombre fichero) : compara los ficheros y si no produce salida, son identicos

InputStream: lee desde un sitio un fichero
PrintStream: imprime desde un sitio un fichero

 */


 EVENTOS:
 SWING TAX
 es cuando yo interactuo con una aplicacion, esa aplicacion hace algo. una interfaz de usuario
 yo pulso un boton, la app realiza una accion. 
 es lo que ocurre cuando inteactuo con una aplicacion 
 GUI FORM en new
 armo mi interface con labels, texto, buttons, luego tengo que crear JFrame en codigo e instanciarlo

 package swingTax;

import javax.swing.*;

public class MainForm {
    private JTextPane pricePane;
    private JTextPane IVAPane;
    private JTextPane TotalPane;
    private JButton buttonCalculate;

    public static void main(String[] args) {
        JFrame frame = new JFrame("SwingTax");
        
    }
}

CreateListener es crear algo que esta a la espera que un evento se produzca
Patron observador, cuando un evento se produce se invoca a un metodo que reciben los escuchantes
el emisor manda un msj y llega a todos los receptores

package eventos;

import java.util.ArrayList;

interface Mensajero {
    void hanSaludado();
}

class Receptor implements Mensajero {
    @Override
    public void hanSaludado() {
        System.out.println(Math.random());
    }
}

class ReceptorMusical implements Mensajero {
    @Override
    public void hanSaludado() {
        System.out.println("Soy un receptor musical");
    }
}

class Emisor {
    private ArrayList<Mensajero> receptores = new ArrayList<Mensajero>();

    public void meteReceptor(Mensajero receptor) {
        receptores.add(receptor);
    }

    public void saluda() {
        for (Mensajero ml : receptores) {  //recorre todos los mensajeros del arraylist
            ml.hanSaludado();
        }
    }
}



public class Main
{
    public static void main(String []args) {
        Emisor emisor = new Emisor();
        Receptor receptor = new Receptor();
        Receptor receptor2 = new Receptor();
        Receptor receptor3 = new Receptor();
        Receptor receptor4 = new Receptor();
        ReceptorMusical rm = new ReceptorMusical();

        emisor.meteReceptor(receptor);
        emisor.meteReceptor(receptor2);
        emisor.meteReceptor(receptor3);
        emisor.meteReceptor(receptor4);
        emisor.meteReceptor(rm);

        emisor.saluda();
    }
}
//una clase que manda msj a una interfaz, entonces todas las clases que implemeten esa interfaz
//van a ser capaces de interceptar el evento que generemos en el emisor y ejecutar el codigo necesario
eventos algo que se produce en el codigo sobre lo que se va a reaccionar
EJMPLEO XML:
package ejemploXML;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;

public class Main
{
    public static void main(String []args) {
        File file = new File("datos.xml");
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();  //crea un patron tipo factoria

        try {
            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();

            try {
                // Analizamos el documento
                Document document = documentBuilder.parse(file);

                // Obtenemos usuario y clave
                String usuario = document.getElementsByTagName("usuario").item(0).getTextContent();
                String clave = document.getElementsByTagName("clave").item(0).getTextContent();

                // Mostramos usuario y clave:
                System.out.println("Usuario: " + usuario + " Clave: " + clave);

                // Vamos a mostrar el atributo "proveedor"
                NamedNodeMap atributos = document.getElementsByTagName("videos").item(0).getAttributes();

                for (int i = 0; i < atributos.getLength(); i++) {
                    String atributoNombre = atributos.item(i).getNodeName();
                    String atributoValor = atributos.item(i).getNodeValue();

                    System.out.println("Atributo " + atributoNombre + " contiene " + atributoValor );
                }

                // Mostramos los videos que hay asociados
                NodeList videos = document.getElementsByTagName("videos");

                for (int i = 0; i < videos.getLength(); i++) {
                    Node video = videos.item(i);
                    System.out.print(video.getTextContent());
                }

            } catch (Exception e) {
                System.out.println("Error procesando documento:" + e.getMessage());
            }

        } catch (Exception e) {
            System.out.println("Error al utilizar el builder: " + e.getMessage());
        }


    }
}

EJEMPLO JSON:
package ejemploJSON;

import org.json.*;


import java.io.FileInputStream;
import java.io.InputStream;

public class Main {
    public static void main(String []args) {

        try {
            // Creamos el inputstream desde un fichero
            InputStream is = new FileInputStream("datos.json");

            // Creamos un tokenizador que leera desde nuestro IS
            JSONTokener tokener = new JSONTokener(is);

            // Y se lo pasamos a una instancia de la clase JSONObject
            JSONObject obj = new JSONObject(tokener);

            // Sacamos las credenciales:
            JSONObject credenciales = obj.getJSONObject("credenciales");

            String usuario = credenciales.getString("usuario");
            String clave = credenciales.getString("clave");

            System.out.println("Usuario " + usuario + " clave " + clave);

            // Dentro de credenciales tenemos los videos:
            JSONArray videos = credenciales.getJSONArray("videos");
            for (Object video : videos) {
                System.out.println(video.toString());
            }

        } catch (Exception e) {
            System.out.println("No puedo leer el fichero: " + e.getMessage());
        }
    }
}



