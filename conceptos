Paradigmas de la programacion:
    IMPERATIVOS: mas antiguo, secuencia de instrucciones, tipo un paso a paso. 
    DECLARATIVO: se centra en el que, en lugar del como. se centra en el resultado final. 
Ejemplo:

const listaProgramadores = ["Gorka", "Martin", "Alex", "Leire"]

let nombres = []

//Programacion imperativa
listaProgramadores.forEach ((programador, posicion) => {
    nombres[posicion] = programador
})

//Programacion declarativa

nombres = [...listaProgramadores]

Ventajas:
    mas facil y legible el imperativo, la escalabilidad del codigo (ocupa mas lineas el imperativo, mas largo)


PARADIGMAS FUNCIONALES VS PROCEDIMENTALES:
    PROCEDIMENTALES: similar al imperativo, lleva mas lineas
    FUNCIONALES: bloques de codigo, en los cuales introducimos un parametro y obtenemos otro, en base a esos codigos ir creando nuestro programa. 
    se define una funcion, y despues la usamos en el codigo. 

DIVISION POR NIVELES: mas bajo es el nivel, mas caracteristicas especificas voy a poder tocar dentro del hardware. ç
    Lenguaje Maquina: 01010101010101
    Lenguaje Ensamblador: intermedio entre humano y maquina, con instrucciones especificas, el primer lenguaje de Programacion
    Bajo Nivel: son estos dos anteriores, relacionados con el hardware y la arquitectura. 

    Medio-bajo Nivel: C es antiguo, tiene capacidades de alto nivel y tiene capacidades de bajo nivel, C++ TAMBIEN. tienen acceso a los registros de la memoria.
    Medio-alto Nivel: Lenguajes de programacion modernos, Python, Java, Javascript.
    Alto Nivel: Lenguajes o frameworks de alto nivel, basados en los anteriores de medio nivel. Un framework es una serie de funcionalidades extra que se añaden a lenguajes ya conocidos en base a librerias, para que programar con estos lenguajes de medio nivel sea mas facil. 

PROCESO DE CONVERSION: necesitamos un traductor, para que nuestro lenguaje sea traducido en 1 y 0. 
    Existen dos formas: lenguajes de programacion compilados e interpretados. 
        compilador: C++, transforma nuestro codigo de lenguaje para hacer la salida. 
        interprete: Javascript o Python, no necesita compilador para que la maquina lo entienda, recien en la salida nos aparecen los errores. 

DESARROLLO DE CODIGO:
    Entorno de desarrollo integrado IDE: son programas con caracteristicas que nos ayudan a programar.Notepad++, Visual Studio Code, Atom, Sublime text, etc.

CONTROL DE VERSIONES:
    a principios de los 2000 se creo GIT, para controlar las versiones, revisar cambios. el primero fue el CVS (Concurrent Version System).

INTRODUCCION A LOS LENGUAJES DE PROGRAMACION:
    PYTHON: es el mas utilizado, se usa para todo, tiene frameworks para ayudar a desarrollar web (DJANGO y FLASK)
    es un lenguaje facil de aprender y utilizar, es un lenguaje interpretado.

    JAVA: es el mas utilizado por las grandes corporaciones, apps webs, es el lenguaje base para apps android, android studio es similar la sintaxis a java
    es sencillo de aprender.

    JAVASCRIPT: es el mas utilizado para web y para apps webs, ECMA es el organismo regulador de este lenguaje, no tiene pagina web. 
    las nuevas empresas estan usando NODEJS para sus servidores, es un framework de Javascript.
    mas facil de aprender que Java. es el mismo lenguaje para cliente y servidor.

    TYPESCRIPT: basado en Javascript, de microsoft, con funcionalidades extras. 
    aplica los tipos a Javascript, es decir, que hay que definir los tipos de variables. 
    es mas complejo que Javascript. 

    C#: es un lenguaje versatil, derivado de C y C++, es para backend, videojuegos, apps de microsoft
    se lo usa para videojuegos en el motor Unity
    es de dificultad moderada. 

    ASP.NET: Es un framework para hacer apps webs, apis, y sitios webs. creado por microsoft.
    dificultad moderada. es todo relacionado a microsoft. 

    PHP:uno de los lenguaje mas utilizados para desarrollar apps web. es de backend de servidores. 
    compite con Javascript y Python. mucho apoyo de la comunidad, muy sencillo de aprender
    webs mas lentas en comparacion a lenguajes mas modernos. 

    HTML: Hyper Text Markup Language, es un lenguaje de etiquetado. w3c decide los parametros de HTML. 
    todos los navegadores tienen que ser capaces de interpretar este lenguaje, 
    se usa para crear sitios webs y apps web pero estaticas. si queremos interactivas, necesitamos otro lenguaje (Javascript)
    es muy sencillo. si quiero programar web tengo que aprenderlo si o si. es como para crear el esqueleto de una pagina.

    CSS: Cascading Style Sheets, despues de hacer el esqueleto de la web con HTML, si le quiero dar color y forma, puedo usar CSS. 
    es lenguaje de diseño grafico, es en forma de cascada, forma parte de la triada web HTML, CSS, JAVA SCRIP (todas para hacer web)
    aplica estilos a una pagina web HTML. 

    AJAX: Asynchronous JavaScript And Xml, se usa para complementar las caracteristicas de Javascript dentro de una pagina web.
    tecnica de desarrollo web para crear apps webs asincronas, es una extension de Javascript para interactuar con servicios externos. 
    nos permite mantener la pagina web (html) en standby y esperar a recibir la info de base de datos sin recargar la pagina, 
    a traves de Javascript seriamos capaces de rellenar esa informacion que necesitamos sin necesidad de actualizar la pagina. 

    RUBY: se usa para servidores, Ruby y Ruby On Rails no son lo mismo. Ruby on Rails (es un framework para ruby para poder crear apps webs y paginas webs)
    como twitch, twitter, kickstarter,soundcloud, es facil de aprender.

    PERL: originalmente era para manipulacion de texto, tipo procesadores de texto, se usa para la administracion de sistemas, 
    desarrollo web, desarrollo de GUI (Graphic User Interface), es de complejidad moderada.

    DART: inicialmente desarrollado por google, se usa para web,servidor y movil. sintaxis del estilo C. Es complejo de aprender, y comunidad pequeña.
    
    KOTLIN: se desarrollo para tener las mismas aplicaciones que java pero mas moderno, es mas sencillo de usar que java con el mismo output -JAR.
    puede interactuar con codigo JAVA. Se usa para desarrollar aplicaciones moviles. 
    si se tienen proyectos en JAVA, se pueden migrar a KOTLIN. se usa sobre todo para Android.

    SWIFT: Lenguaje para programar aplicaciones IOS. es de APPLE. soporte solo a partir de IOS07.
    
    LENGUAJES MAS DEMANDADOS: JAVASCRIPT, HTML/CSS, PYTHON, SQL, JAVA, NODEJS, 

PARADIGMAS DE PROGRAMACION: formas de programar en diferentes Lenguajes
    PROGRAMACION ESTRUCTURADA: es una programacion por secuencia de instrucciones, funciona solo cuando se necesita algo simple o sencillo. 

    PROGRAMACION ORIENTADA A OBJETOS: en la mayoria de casos se usa esto. no es de secuencia, lo mas importante son los objetos. 
    la finalidad es que los objetos se interrelacionen, para que el usuario pueda acceder a todos los objetos o los que requiera. 
    lo mas importante de los objetos es que tiene dos tipos de propiedades: 
        los DATOS o ATRIBUTOS. Estos pueden ser: nombre,nombre usuario,apellidos,edad,email,etc.
        las FUNCIONES o FUNCIONALIDAD a traves de los metodos. Nos permite añadir funcionalidad.
        Puede ser: login,registro,editar_perfil,logout,comprar,etc. 
        Cada objeto tiene dos caracteristicas, atributos y funcionalidad. 

        Para crear los Objetos usamos las CLASE, que es un template. esto ya tiene atributos y funciones, en base a esta plantilla
        vamos creando objetos diferentes.Por ejemplo: Clase USUARIO, a partir de ese template,
        creamos los damos objetos usuarios, con diferentes caracteristicas, se llama instanciar. 
        cada uno de estos objetos, sobre el template, es una instancia. 

        4 CONCEPTOS DE OBJETOS:
            ABSTRACCIÓN: proceso para definirle los atributos y funcionalidad al objeto.
            ENCAPSULAMIENTO: dentro de un mismo objeto, tener todos los atributos y metodos para poder tratar
            ese objeto como una variable. 
            HERENCIA:desde una clase, podemos derivar otras clases. el primer objeto seria el clase padre
            y desde alli, podemos crear nuevas clases (objetos) hijo, es decir, hereda los atributos
            y metodos del padre, es decir de la primer clase, a eso se le puede agregar 
            o modificar metodos, eso se llama reveldia, revelarse a sus padres. 

            POLIMORFISMO: Multipleforma, es decir, podemos usar un mismo metodo, pero 
            con distintas formas, por ejemplo: registro (email), registro (facebook), registro (github).

    PROGRAMACION FUNCIONAL: su puede usar con los dos anteriores, 
    Usa FUNCIONES PURAS: al llamarse una vez, se obtiene un resultada y todas las veces que se llamenn,
    siempre devuelve el mismo resultado. Cuando cambia alguna variable, a medida que llamo a la funcion
    eso no es una funcion pura. 

    FUNCIONES SIN ESTADO: para esto se usa la recursividad, es cuando una funcion se llama asi mismo. 
        //RECURSIVIDAD.
        // CALCULO FACTORIAL DE UN NUMERO ENTERO
        // FACTORIAL DE 5 = 5 * 4 * 3 * 2 * 1 = 120

        // FUNCION NO RECURSIVA QUE TIENE UN ESTADO INTERNO (PROGRAMACION ESTRUCTURADA)
        function factorial (num) {
            let fact = num
            for (let i = num -1; i > 0 ; i= i -1) {
                fact = fact * i
            }
            return fact
        }

        console.log (factorial(5))

        //FUNCION RECURSIVA (que se vuelve a llamar) (PROGRAMACION FUNCIONAL)
        function factorial_rec(num) {
            if (num == 1) return 1
            return num * factorial_rec (num -1)
        }


    Ejemplo:

    function suma (num1, num2) {
        return num1 + num2
    }

    function multiplica (num 1, num2) {
        return num1 + num2
    }

    //ESTA FUNCION USA OTRA FUNCION PURA, y sigue siendo pura ya que se compone de dos puras.
    function suma_y_multiplica (num1, num2) {
        return suma (num1, num2) * multiplica (num1, num2)
    }


    console.log(suma(1,4))
    console.log(multiplica(1,4))
    
FRONTEND Y BACKEND:
    La diferencia es que el front es la pagina en donde el cliente ve todo, programa la interfaz, solo lo visual para representar los datos y el back es donde no se ve todo lo que viene por detras, para que esa pagina o servicio funcione. El back se encarga de dar toda la info para el frontend. Esta todo interconectado. Desde el cliente, se hace una consulta, se llama al servidor, el cual puede hacer una consulta a una base de datos. Ese servidor tiene que acceder a noticias, usuarios, estilos. Cuando se tiene toda la informacion desde el back, se manda al frontend, y el cliente pueda interpetrar. La mayor parte del calculo debe estar en el backend. 
FULLSTACK: es front y back, es programar las dos cosas. stacks: estructuras o conjuntos. 

LENGUAJES DEL LADO DEL SERVIDOR: JAVA,RUBY,PHP,ASP.NET,PERL,C#,PYTHON, NODEJS (framework de javascript). Algunos tambien sirven para desarrollar aplicaciones de cliente, como PYTHON Y PHP. Se encargan de liberar la mayor carga computacional al cliente, la informacion. 

LENGUAJES DEL LADO DEL CLIENTE: {HTML,CSS,JAVASCRIPT} TRIADA MAS UTILIZADA, AJAX,TYPESCRIPT. 

CMS: Content Management System. Es un software que tiene su propio frontend y su backend, a traves de un CMS sos capaz de crear una pagina web sin necesidad de programar el front ni el back. Cada uno tienen acceso a una base de datos. Nos da muchisima agilidad al momento de crear paginas web. Algunos son: {WORDPRESS, JOOMLA, DRUPAL, MAGENTO, PRESTASHOP} estos cinco estan programados en php y javascript, ,{SHOPIFY esta creado en HTML Y javascript, enfocado en la creacion de paginas online, ODOO esta programado en Python y en javascript, la mayor parte de su desarrollo esta enfocado en CRM (Client Relationship Manager).

FRAMEWORKS: estructuras o marcos. es una serie de librerias que facilitan la creacion de paginas webs, servidores, etc. no son lenguajes de programacion, si no que complementan a los lenguajes. 
    Frameworks del cliente: ayudan a crear aplicaciones desde el punto del vista del cliente, es decir, desde el frontend. 
        Ejemplos: *AngularJS, ViewJs, ReactJs (los mas usados y utilizan Javascript).
        *Laravel, usa el lenguaje PHP, es de los mas utilizados 
        *Spring, usa el lenguaje JAVA
        *Microsoft.Net, usa C#.
        *Flash y Django usa Python. 

    Frameworks del servidor:Estan los dos mas utilizados en Javascript. EXPRESS JS y ADONIS JS.

    Frameworks de test unitarios: cuando desarrollamos una app y queremos que funcione bien, es una obligacion de realizar pruebas para que funcione bien. Los mas utilizados:
        *JEST: usa el lenguaje Javascript, a traves de la programacion se realiza en javascript.
        *JUNIT 5: para lenguaje JAVA. 
        *PHPUNIT: lenguaje PHP.
        *NUNIT Y XUNIT.NET: lenguaje en .NET (el de microsoft)
        *PYTEST: lenguaje Python. 

LIBRERIAS HTML desde el punto de vista el cliente, que manejan HTML.
    REACTJS: ayuda a trabajar con el DOM (Document Object Model), es decir para manipular la parte visible del HTML, se puede cambiar textos, colores, funcionalidades de botones,  
    JQUERY: ayuda a trabajar con el DOM (Document Object Model), es decir para manipular la parte visible del HTML, se puede cambiar textos, colores, funcionalidades de botones,  
    BOOTSTRAP: Una de las mas utilizadas, ayuda con los estilos, CSS (estilos), clases de las etiquetas, para crear botones, ventanas, animaciones, etc.

SERVIDORES WEB: servir paginas web, archivos mp3, archivos videos mp4,pdf, cualquier archivo. no deja de ser un soft. 
    APACHE: es el mas utilizado, es multiplataforma,  
    NGNIX: es un poco mas rapido que apache, 
    TOMCAT: uno de los clasicos. 
    OPENLITESPEED: version de codigo abierto de litespeed.
    MICROSOFT IIS: 
    NODEJS: desde 2009, programado en javascript,sirve para tener el mismo lenguaje desde cliente como servidor. 
Nos pueden servir para conexiones NFTP, servidor de correo electronico, servidor WEB, servidor de base de datos (como proveedor de base de datos)

NAVEGADORES: los mas usados 
    MICROSOFT EDGE: viene por defecto con windows, ex explorer.
    FIREFOX: el segundo mas usado, para desarrollar tiene herramientas buenas.
    GOOGLE CHROME: normalmente es el que se usa para desarrollar.
    SAFARI: si desarrollas apps para iphone, usar este. de APPLE.
    OPERA: el tercero mas usado. 
    BRAVE: centrado en criptomonedas, basado en chrome por su codigo fuente (chromio), 

STACKS: conjuntos de tecnologias que me permiten crear una pagina web en modo fullstack. desde el cliente y desde el servidor. 
    
    *XAMPP (Multiplataforma Apache MySql Php Perl Python), LAMP (Linux Apache MySql Php) Y WAMP (Windows Apache MySql Php Perl Python): son los mas usados, basados en APACHE.
    
    *MERN (MongoDB Express Reactjs NodeJs), MEAN (MongoDb Express Angular NodeJs), MEVN (MongoDb Express ViewJs NodeJs), PERN (Perl Express ReactJs NodeJs) : todos basados en Javascript y en NodeJS. Podes usar las combinaciones que quieras, pero en funcion de las tecnologias que usas se definen los stacks. 

INTRODUCCION AL DESARROLLO MOVIL: 
    PLATAFORMAS MOVILES: los mas usados son estos dos 
        ANDROID
        IOS

    ENTORNOS DE DESARROLLO ESPECIFICOS PARA CADA PLATAFORMA: IDEs y Emuladores
        XCODE: para IOS
        ANDROID STUDIO: para Android
        cada uno de estos tiene su propio emulador

    LENGUAJES DE PROGRAMACION QUE USAN:
        ANDROID STUDIO usa KOTLIN o JAVA, o los dos, ya que son compatibles. 
        XCODE usa lenguaje SWIFT.

    FRAMEWORKS Y LIBRERIAS:
        XAMARIN: usa lenguaje C# con .NET, estos son los de microsoft
        FLUTTER: usa lenguaje DART
        REACT NATIVE: usa Javascript con el framework REACT. Es el que mas se usa. 
        La diferencia entre estos tres, es que cuando creamos apps compilamos la aplicacion nativa, pueden crear para Android o IOS, crean codigo nativo. Mientras que IONIC no compila directo la app nativa, usa un emulador web para poder ejecutar su app, para que parezca nativa. 

        IONIC: es un frame exclusivo en desarrollo movil, desarrolla apps webs basadas en el framework ANGULAR (de Javascript), ademas usa un web view, lo que hace es crear un simulador web que se integra para desarrollar la app y poder ejecutarlo en el celu. Ademas tambien puede usar REACT y VIEW. Usa tambien un bridge, para que tenga funcionalidades nativas. este bridge es APACHE CORDOVA.

DESARROLLO MULTIPLATAFORMA: crear un solo codigo, con ese codigo despues la compilacion cree diferentes tipos de archivos para diferentes sistemas operativos.
un solo codigo, con muchas compilaciones para diferentes sistemas operativos.
    IOS Y MacOS: Sistemas operativos de APPLE.
    WINDOWS: para pc
    LINUX: sistema de codigo abierto
    ANDROID: sistema para celus
    JAVA: JVM (Java Virtual Machine), plataforma donde se ejecutan los programas compilados en java. Maquina virtual que permite ejecutar apps escritas en JAVA. 

    LENGUAJES EN DESARROLLO MULTIPLATAFORMA: estos son los mas usados, pero por si mismos no dicen nada. Se usan diferentes librerias o frameworks para desarrollar apps que funcionen en multiplataforma.
        JAVASCRIPT:
        JAVA:
        PYTHON:
        C#:
        RUBY:
        DART: 

    FRAMEWORKS DE DESARROLLO MULTIPLATAFORMA: el objetivo es crear un codigo que se pueda mantener para que funcione en diferentes sistemas operativos. con un mismo codigo crear aplicaciones que puedan ser leidas en distintos sistemas operativos. 
        APACHE CORDOVA: puede hacer de puente entre diferentes lenguajes. seria como una app externa de apoyo a diferentes lenguajes para crear aplicaciones para luego pasarlas a codigo nativo. 
        REACT NATIVE, NATIVE SCRIPT Y APPCELERATOR: los frameworks mas demandados, estan escritos en Javascript. 
        KIVY Y BEEWARE: estos se usan con PYTHON, son frameworks para crear apps multiplataforma. 
        FLUTTER: usa lenguaje DART. 
        CODENAME ONE: usa JAVA.
        RUBY MOTION: usa lenguaje RUBY para crear apps multiplataforma.

    FRAMEWORKS MAS DEMANDADOS:
        FLUTTER: puede crear para IOS o ANDROID. DART
        IONIC: Javascript
        REACT NATIVE:Javascript
        XAMARIN: C#
        NATIVESCRIPT:Javascript
        APPCELERATOR:Javascript

    CONCLUSION: apps multiplataforma vs apps nativas:
        a veces es conveniente usar un solo codigo para diferentes sistemas operativos en caso que seas freelance, usando frameworks multiplataforma. 
        en caso que trabaje para una empresa pueden pedir conocimientos de aplicaciones nativas. 

CODE REVIEW:
    PULL REQUEST: solucion de codigo para ver si funciona, si se hace. pasa un filtro de alguien que revisa el codigo, lo testea, si funciona, se hace el merge branch. 
    Es un revisador de codigo. Una persona lo revisa, lo compara con versiones anteriores (como en GIT), hace comentarios y lo puede aprobar o rechazar, si se acepta se convierte en una nueva version del software, con un merge branch, para unir las dos ramas. 

    PLATAFORMAS DE CODE REVIEW:
        GITHUB Y GITLAB: control de versiones, tambien permite revision de codigo. 
        SONARQUBE:
        CODEFACTOR:
        COLLABORATOR:
        CODESTRIKER:
        GERRIT:
    la revision de codigo se hace con la version vieja y version nueva, y se hace visualizacion de si se agregaron lineas, se borro algo, etc. se mantiene siempre una conversacion con el code reviewer, con comentarios constructivos. 

BASES DE DATOS: es un sistema que permite almacenar informacion desde un punto de vista logico. mas tipica es la formato tabla.
    FASES DE DISEÑO DE BASE DE DATOS:
       1 DISEÑO CONCEPTUAL: crear toda la idea de la base de datos, si se va a relacionar y demas. 
    
       


EJEMPLO DE BASE DE DATOS:

    USUARIOS                        LENGUAJES               ASIGNATURAS

    ID ---- Clave Primaria          ID                      ID
    Nombre                          nombre                  nombre
    apellido                        fecha                   nombre_profesor
    email                                                   numero_horas
    edad
    lenguaje_id (aca con un numero, podemos hacer referencia a la tabla de lenguajes)
    asignatura_id   (para relacionarla con la tercer tabla)

    DE ESTA MANERA SE CREA EL DISEÑO CONCEPTUAL. esta fase es agnostica del proveedor o tecnologia que vamos a usar para esa base de datos. 

  2  DISEÑO LOGICO: 
    Tener en cuenta las diferentes tecnologias para crear esa base de datos. Se elige el proveedor que mas nos interese. una vez definido esto, se empezaria a convertir el conceptual en algo adaptado a la plataforma a usar. Es tipico que tengamos que poner el tipo de variable que vamos a usar en cada campo. 

 USUARIOS                        LENGUAJES               ASIGNATURAS

    ID ---- Clave Primaria          ID (INT)                ID (INT)
    Nombre (VARCHAR 32)             nombre (VARCHAR 32)     nombre (VARCHAR 32)
    apellido  (VARCHAR 64)          fecha (DATE)            nombre_profesor (VARCHAR 32)
    email (VARCHAR 64)                                      numero_horas (DOUBLE)
    edad (INT)
    lenguaje_id  (INT)
    asignatura_id (INT)  

    CON ESTO TENDRIAMOS CREADO EL DISEÑO LOGICO.

    3 DISEÑO FISICO: aca es cuando se crea realmente la base de datos. Creamos la base de datos en la plataforma que hayamos elegido. 

    USUARIOS                        LENGUAJES               ASIGNATURAS

    ID ---- Clave Primaria          ID (INT)                ID (INT)
    Nombre (VARCHAR 32)             nombre (VARCHAR 32)     nombre (VARCHAR 32)
    apellido  (VARCHAR 64)          fecha (DATE)            nombre_profesor (VARCHAR 32)
    email (VARCHAR 64)                                      numero_horas (DOUBLE)
    edad (INT)
    lenguaje_id  (INT)
    asignatura_id (INT)  

    Crear cada una de las tablas o modelos, en funcion de la plataforma que hayamos creado la base de datos. 
    El objetivo del desarrollador es centrarse en el diseño conceptual para prever posibles funcionalidades que pueden surgir, y tenerlo ya diseñado. para no tener que volver a hacer tablas, referenciar, etc. 


BASE DE DATOS SQL Y NoSQL:
    SQL:bases de datos relacionales. se pueden crear relaciones en base a claves de otras tablas. Utiliza claves primarias y extranjeras (Primary key and foreign key). A traves de la foreign se hace relacion a otro dato de otra tabla. 
        PROVEEDORES: MySQL, MARIADB, POSTGRESQL, ORACLE DATABASE.

    NoSQL: Bases de datos no relacionales. se puede tener tablas pero no relacionales. las bases de datos keyvalue son las mas usadas, tenemos claves diferentes y a traves de buscar las claves obtenemos el valor que corresponde a esa clave. este tipo se utiliza no con almacenamiento de memoria, si no con la RAM, por eso son muy rapidas. Si queremos, se pueden configurar como almacenamiento tradicional. 
    *Por otro lado se tienen los objetos, podemos almacenar bases de datos de forma con objetos o documentos. aca no existen relaciones, se puede introducir muchos campos y tipos. Este es un tipo de base de datos flexibles se usan para prototipos y pruebas de conceptos, no necesita una definicion tan estricta como las sql. 
    *Otra de las bases de datos son los graphs, tenemos muchos datos que se llaman nodos, que pueden estar relacionados entre si de cualquier manera. se pueden tener diferentes nodos con los usuarios, intereses, empresas, etc. de esta manera se pueden relacionar entre nodos, esto es tipico para red social.

    PROVEEDORES PARA BASES DE DATOS NoSQL: 
        MONGO DB Y CLOUD FIRESTORE: trabajan con documentos. son las mas usadas,
        CASSANDRA Y REDIS: las tipo keyvalue. 
        GRAPHQL: tipo graphs.

DevOps y CICD:
    Development IT Operations
    Existian dos departamentos Desarrollo Software y Operaciones IT. Asi surgen las DevOps. No es una app, si no una metodologia de desarrollo de soft que consiste en ir desarrollando y publicando codigo de a poco, no esperar tanto tiempo como antes, trabajando de forma diaria los dos equipos. De esta manera, si algo no funciona, los dos equipos tienen la posibilidad de revisar estos cambios pequeños diarios, es mas facil llegar a un entendimiento y solucionarlo. 

    Necesita facilidades: CI / CD. 
        CI: Continues Integration, integracion continua. Publica el codigo a traves de un (merge, pull, push)
        CD: Continues Deployment, despliegue continuo. No publicar el codigo, si no, despleguer la aplicacion a produccion para que se pueda utilizar. 
        no son lo mismo. 
        Es un pequeña automatizacion entre la version del desarrollador, y la version a despliegue. en el medio, realiza acciones. Programa por ejemplo: cuando haya un push, voy a realizar test que estan pre escritos; comprobar otro tipo de casuisticas, solo entonces, cuando todo esto pase de forma correcta, solo ahi, se realiza el push o la subida de codigo. de esta manera sube codigo poco a poco, antes del despliegue. el propio code review tiene el trabajo mas facil a traves de CI. Esta nueva version esta en pre-produccion. El siguiente paso seria hacer el CD, algo similar a esto, con el fin de pasarlo a desplegarse. Se hacen otros test, se configuran los entornos correspondientes, si todo esta bien, se realiza el despliegue. Ahora si se tiene la version desplegada y en produccion. 

    HERRAMIENTAS O SERVICIOS QUE OFRECEN CI/CD:
        ANSIBLE
        HELM
        JENKIS
        GITLAB CI
        GITHUB ACTIONS
        BITBUCKET PIPELINES


CONTENEDORES:
    Esto se empieza a usar cuando anteriormente, cuando alguien desarrollaba una app o un software, necesitaba tener una maquina virtual , sistema operativo y todo lo demas necesario para poder ejecutarlo correctamente y que no haya errores. necesitaba tambien instalar todas las librerias para que pueda funcionar normalmente. esto usaba mucha memoria, aprox 15 mb de app pero habia que sumar unos aprox 500 mb de maquina virtual. 

    Actualmente para reemplazar todo esto, se usan los contenedores. El contenedor seria como un encapsulamiento donde se inserta :
        1 la app (codigo fuente),
        2 librerias o dependecias que necesito para ejecutar, 
        3 le paso las instrucciones del sistema operativo
    de esta forma se genera un contenedor donde puedo ejecutar desde cualquier maquina. 

    Una vez creado este contenedor, se lo puedo pasar a un colega para que a traves de un sofware donde pueda leer ese contenedor, pueda ejecutarlo desde su maquina. 
    Por un lado se tiene la infraestructura, el sistema operativo host o anfitrion, un soft container engine, y los contenedores como tal. este soft container engine ya tiene la info de que sistema operativo necesito para ejecutar esa app, aprox se manejan 40 mb por cada contenedor contra 500 mb de la anterior forma. 
    se usan menos recursos del sistema usando contenedores, a traves del motor de contenedores (container engine)

    TIPOS DE CONTENEDORES:
        DOCKER: el mas usado
        PODMAN: cada vez se usa mas los contenedores en podman, tiene algunas mejores de rendimiento. 

ORQUESTACION:
    ROL DE DESARROLLADOR:
        supong que quiero realizar una web F (front end)
        esta interfaz necesita tener acceso a un servicio de B (back end)
        necesito acceso a base de datos DB (por ej mongodb)
        Entonces, necesito hacer tres contenedores que tenga F,B Y DB. 

entonces falta alguien que me diga que es lo que tengo que hacer con estos tres, es decir que estas tres cosas esten subidas y acceso a internet, por ejemplo. 
Aca entra lo que se conoce como MASTER. 
    Se encarga de llevar estos tres contenedores F,B, Y DB, y llevarlos a un sistema. 
    Los ORQUESTADORES nos ayudan con:
        Deploy
        Scaling
        Network
        Insight
        Purge (purga de contenedores que no funcionan)

ROL DE OPERACIONES IT:

en caso que usaramos un servicio de orquestacion, tendriamos diferentes NODOS. 
    NODO 1: F,     B ,     DB.   
    NODO 2: F,     B ,     DB
    NODO 3: F,     B ,     DB
            -      -       -
            -      -       -
            -      -       -
        SERV1    SERV2   SERV3
Entonces tendria un servicio centralizado para las 3 copias de mi aplicacion, para cada uno de mis contenedores F o B o DB, para poder corregir en caso que sea necesario.

El MASTER desde el punto de vista de la orquestacion, me da facilidad para desplegar mis contenedores (nodos). Me ayuda tambien a escalar (Scailing) por ej, en caso que el F tenga demasiadas visitas y necesite el doble de recursos. entonces el Master me puede crear un nodo nuevo con dos veces F mas B y DB. Esto es escalar, me permite aumentar los recursos que estoy destinando a los diferentes contenedores de manera sencilla. 
Me permite crear un nodo para cada una de mis aplicaciones. 

Supongamos que mi F se conecta en algun momento con mi DB, que no deberia ser asi. Entonces un servicio de orquestacion me da reportes en tiempo real para ver cuantas conexiones hay entre los contenedores. Asi puedo determinar cuando hay problemas de conexion entre Front y las Bases de datos, lo que me generaria un problema de seguridad, ya que nunca debe ser accedida la DB desde el F.

Suponer tambien que deja de funcionar F en alguna de las copias de la app, entonces el servicio de orquestacion elimina esa parte y la sustituye por otro F que si funciona. 

    SERVICIOS COMERCIALES de Orquestacion:
        DOCKER COMPOST
        KUBERNETES: mas usado
        OPENSHIT

CLOUD COMPUTING:
    Suponemos que desarrollo una app, puedo tenerla desde un servidor fisico accesible, como puede ser una compu que no use. 
    Tambien tengo la opcion de contratar algun servicio de cloud computing, en el cual desplego mi app para que este constantemente funcionando, lista a ser usada. 
        *Mantenimiento: en el fisico necesito mucho mantenimiento. En cambio en la cloud, el mantenimiento viene por parte del proveedor.
        *Coste Conjunto: En el fisico tengo una compu para ser usado en una app chica, para lo cual uso muchos recursos disponibles para ser usado en poca capacidad. En la cloud, el pago es por el uso, no pago de mas. 
        *Escalabilidad:Suponemos que esta app necesita escalar, es decir, necesito otro servidor por ejemplo o segunda compu. la escalabilidad seria en el fisico, conectar dos compus en red para que ese servicio pueda usar recursos de las dos compus. En la cloud, la escalabilidad es mas facil, contrato el doble de recursos, se paga un poco mas y se escala la app.
        *Seguridad: si se tiene fisico, se debe realizar los acoples de seguridad necesarios para evitar conexiones malignas. En la cloud, se encarga de la seguridad el proveedor de ese servicio de cloud computing. 

    SERVICIOS COMERCIALES DE CLOUD QUE MAS SE USAN AHORA:
        AWS: AMAZON WEB SERVICES
        GOOGLE CLOUD PLATFORM: SERVICIO DE GOOGLE
        AZURE: SERVICIO DE MICROSOFT

TESTING: hacer una prueba y el soft nos dice si pasa la prueba o no.
    QUALITY ASSURANCE: QA(Departamento de control de calidad de software), ellos testean los soft para asegurarse que funciona y que cumple con los estandares pedidos. 

TEST DE LAS CAJAS Y TIPOS DE TEST:
    TEST DE LA CAJA NEGRA (solamente testeo la entrada y la salida, no veo lo que hay adentro, para 1 tipo de entrada, haya 1 tipo de salida, no me interesa lo que pasa dentro. )
             +
    TEST DE LA CAJA BLANCA (testea lo que pasa dentro, cuando le doy entrada, quiero ver que pasos sigue esa entrada,y tambien tendra una salida pero no me interesa, solo quiero ver el camino que recorre lo que entra)
             =
    TEST DE LA CAJA GRIS (testea las dos cosas juntas, por ejemplo la prueba de interfaz y combina con pruebas de caja blanca. yo tengo una entrada, la sigo por dentro, y ademas testeo la salida del software.)

    TIPOS DE TEST: 
        TEST FUNCIONALES: testea funcionalidades que se supone que la app debe cumplir. Se centran en la funcionalidad. Apoyo en los requerimientos de usuario final/cliente. Tambien testea los errores (situaciones negativas), los posibles errores que puedan surgir a lo largo de la app/web. Por ejemplo: desarrollar una pantalla en caso que haya errores o que no se haya conexion a internet en una web. 
        TEST NO FUNCIONALES: testea todo lo que hay alrededor de esa app. Testea rendimiento: tiempos de carga, stress test (lleva el soft hasta el extremo para maximizar los recursos que consume, por ej. para una web, se simula para tener 1000 visitas simultaneas), escalabilidad (cuando recien se escala el soft, queremos hacer un stress test, como se comporta con respecto a los nuevos recursos que se le asignan); accesibilidad (para personas con visibilidad reducida, o para pantallas pequeñas, etc.), UX/UI (User experience, User Interface, que seria la interfaz como funciona), Tests de seguridad (ataques de DOS a nuestro soft).

        
INTRODUCCION A LAS COLAS DE MENSAJES:
    ENCOLAMIENTO DE MENSAJES (MESSAGE QUEUEING): supongamos que tengo un F (front end), que se tiene que conectar con un B (Backend), este back me devuelve una respuesta. Esto se hace, haciendo una llamada desde el F al B, y me devuelve del B. 
    Supongo que tengo mas de una llamada, escalando en varias llamadas, en algun momento el B llega a un punto en donde los recursos destinados a ese back llegan a su limite,y colapse. puede ser que haya un fallo cuando no se produce una llamada, esto siempre va a ser mejor que haya delay para la respuesta del B antes que no haya nada. De este modo surgen las colas de mensajes, que no son mas que una interfaz intermedia entre el F y el B, en donde se almacena en cache los mensajes que llegan al B, para llevarlos de forma ordenada  y no colapsar el sistema. En este caso, la Q (cola) es la que se conecta el B y gestiona las prioridades de los mensajes. No todas son asi, a veces trabajan entre servicios y backend. Permite tener un sistema asincrono, no es lineal, se hacen las llamadas y despues nos llegaran las respuestas. 

    MENSAJE:
        Informacion (datos) que debe ser transmitida de un punto a otro. Todo tipo de datos, archivos, textos, mensajes, documentos, etc.
    
    TIPOS DE ESTRUCTURAS DE DESARROLLO WEB SEGUN PUNTO DE VISTA DE Q:
        *ESTRUCTURA PUNTO A PUNTO: Ejemplo, servidor de correo. tiene entre los mail saliente y entrante, tiene un gestor de mails (Q) para almacenar cierta cantidad de mails. 
        tiene parte de PRODUCER (los que generan los mensajes), intermedio Q (cola) y por ultimo el CONSUMER (consumidor o receptor). 
        *ESTRUCTURA PUBLICADOR-SUSCRIPTOR:
        Tenemos el PUBLISHER. La diferencia con el anterior, es que la anterior gestiona colas de un productor a un consumidor, es decir de 1 a 1. en cambio en esta , el publisher es uno, pero el SUSCRIBER puede ser n (muchos).

    BENEFICIOS:
        DISOCIACION DE APPS (las puedo desacoplar, metiendo un midware, que no dependan una de la otra)
        ESPECIALIZACION DE APPS (se puede especializar a cada una, si no tiene la Q, se tiene que crear una app que gestione tanto el F como el B, pero teniendo Q, se puede hacer apps solo para F y solo para B)
        ESCALABILIDAD (ayuda a escalar)
        PROCESAMIENTO (si estoy desarrollando apps sin colas de mensajes, puede ser que tenga que desarrollar toda la app en un mismo lenguaje, pero capaz este lenguaje vaya mejor en B que en F, y necesitaria usar frames o servicios) entonces teniendo Q nos permite tener apps para F y otra para B de destintos lenguajes, y frames.
        EVOLUCION
    PROVEEDORES:
        RABBIT MQ: gestor de colas mas utilizado
        REDIS: otro gestor open source, tiene servicio de colas de mensajes. 

CLIENTE - SERVIDOR:
    DEFINICIONES: Se tiene por un lado el dispositivo cliente (celu, compu,notebook,etc) a traves del cual se entra a internet. Se dice asi xq solicita una serie de servicios o cierta informacion. 
    El dispositivo movil cliente lanza la peticion por ej google.com, esa direccion lleva directamente a un servidor o servidores. Ese servidor puede trabajar esa informacion que le llega y devolverle al cliente .entonces a traves de internet se le muestra la pagina al cliente, regresa la peticion, y el dispositivo es capaz de interpretar. 
    Los dispositivos de cliente acceden a internet a traves de distintas apps: google chrome, safari, prhotoshop. estos interpretan lo que nos devuelven de los servidores. 

    ESTRUCTURAS POR NIVELES:
        1 SOLO NIVEL: Tener todo en una misma maquina, es tipico cuando se desarrolla una app en nuestro dispositivo (servidor, base de datos y cliente) en un mismo lugar. Modelo Cliente-Servidor en un solo nivel. 

        2 DOS NIVELES: Cliente (maquina o dispositivo) a traves de internet tiene acceso a otro dispositivo donde esta almacenado el servidor y la base de datos. Cliente por un lado, y servidor y base de datos por otro lado. con conexion de internet en el medio. 

        3 TRES NIVELES: Cliente (dispositivo maquina, movil, etc) a traves de internet lleva a un servidor y luego a traves de internet lleva a la base de datos. los tres separados en dispositivos y conectados por internet. 

        Existen MODELOS DE NIVELES: (N NIVELES): lo mismo, solo que a traves de internet accede a diferentes servidores, que estan en distintos dispositivos. 
    TIPOS DE SERVIDORES Y MODELO P2P:desde el punto de vista de apps.
        SERVIDORES WEB: sirven los archivos necesarios para la web.
        FILE SERVERS: intercambio de archivos, solo archivos. 
        EMAIL SERVERS: apps que permiten servicio de mail.
        VPN SERVERS: Virtual Point Network permiten acceder a diferentes servicios alojados de forma local pero de forma remota, a traves de ellos, puedo hacerme pasar como si estuviera en mi oficina. 
        PROXY SERVERS: similar al anterior, solo que accede a ciertas direcciones solo que a traves de tunel y se hace pasar por otra direccion IP.

        MODELO P2P: Peer to Peer.
            modelo descentralizado donde el modelo cliente-servidor no existe. se usa con blockchain. conectados en red, acceso a mismos datos. directamente se conectan entre clientes, a sus dispositivos. se coteja la informacion. 

MODELO VISTA CONTROLADOR: patron de diseño de arquitecturas de programacion, no es lenguaje ni framework. todos pueden adaptarse a este patron de diseño.
    MVC: Modelo Vista Controlador. cada parte representa una parte de la app especifica.
    Modelo: acceder y manipular los datos. puede ser acceso a una base de datos. 
    Vista: Mostrar los datos del modelo y proporcionar la interactividad al usuario. 
    Controlador: su  funcion es coordinar al modelo y a la vista. Es qien decide a que parte del modelo llamar y a que vista. es el que dirige. 

    Historia de MVC: patron mas utilizado. introducido en los 70, popularizado en el 88. es el mas usado en apps webs. tiene paradigmas derivados: HMVC, MVA,MVP,MV VM, etc. 

    Suponemos que tenemos un dispositivo, quiero acceder a google y buscar MVC. entro al navegador y buscar, o sea interactuo con el controlador. y de ahi, pregunta que es lo que tengo que mostrar. primero hace llamada al modelo, tengo que mostrar "x cosa". luego cuando tiene la info el modelo, la devuelve al controlador. ahora hace llamada a la vista, para mostrar esa info de forma ordenada. Una vez generada esa vista, vuelve al controlador. luego, con esa vista, el controlodar muestra con esa vista al cliente.

    Supongamos que quiero buscar que es MVC. le digo al controlador que tiene que hacer una busqueda, ahora ya no tiene que buscar en el modelo, hace una llamada en el modelo pero tambien hace busqueda.entonces el modelo le pasa al controlador un archivo con todos los resultados que encontro dentro de la base de datos. ahora el controlador, hace llamada a vista, para que hagan la muestra de pantalla de los datos que necesitaba. el controlador devuelve la vista, que es diferente a la primera donde solo hacia la entrada en google. 

INTRODUCCION A HTTP: Es el estandar de comunicaciones via web.
Se relaciona con el modelo cliente-servidor. La conexion desde un dispositivo con internet se realiza a traves de un protocolo estandar que es HTTP. hace referencia a la conexion a traves de internet para obtener datos. 
HTTP: Hyper Text Transfer Protocol. Inicialmente era para transmitir archivos HTML, ya que era unicamente para hiper textos. despues fue evolucionando, ahora transfiere CSS,JS, archivos, videos, etc.
Ejemplo: entramos a una pagina web, se descarga el html. luego se obtiene css y javascript para la interactividad con el usuario. a su vez se analizan llamadas(el mas usado es el get), a traves de estos metodos se tienen diferentes partes que conforman nuestras paginas web. Luego estas llamadas http, van a los servidores para obtener datos. se obtienen imaganes, videos, anuncios,etc. 
Protocolo: conjunto de reglas estandarizadas con el fin que diferentes tecnologias y lenguajes sean capaces de conectarse entre si. no excluye ninguna tecnologia. asi hace que internet sea un ecosistema universal. 
Ejemplo: peticion de http y respuesta. 
    Peticion: hace una llamada get, pasa el protocolo y la version. el mensaje que envia desde el dispositivo hasta internet. Desde internet se recibe una RESPUESTA. La respuesta trae el protocolo, la version de ese protocolo, el codigo, el header o encabezado del mensaje, y el mensaje. Si es cifrada es HTTPS. 

    HISTORIA Y VERSIONES DE HTTP:
        HTTP 0.9: nacio en 1991. primera version. solo soporta metodo GET (para obtener cierta informacion, solicita datos). no soporta Headers.
        HTTP 1.0: 1996. se usa en servidores proxy. Metodos GET, HEAD y POST. 
        HTTP 1.1: mas usada hoy. conexiones persistentes esten activadas por defecto, es decir, las anteriores eran conexiones unitarias se cortaba cada vez que hacia algo. ahora se usa el pipelining, agrupa llamadas o request para que no se hagan una por una, si no que engloba las peticiones o llamadas, obtiene todo a traves de una, para cada uno de los servidores. 
        HTTP 2.0: año 2015. misma semantica de version 1. Mejoras en el empaquetamiento de datos. 
        HTTP 3.0: año 2016. sustituye protocolo TCP por el de UDP. 

    METODOS DE HTTP:
        Tipos de peticiones: son sugerencias, cada servidor las traslada como mejor le convenga.
            Las que mas se usan:
                GET: obtener datos a traves de request y un response.
                POST: Enviar datos, crear nuevos recursos. crear bases de datos, conexiones a bases de datos. 
                PUT: mismo que post, pero para editar. envia datos, edita recursos existentes.
                DELETE: para eliminar recursos existentes.
                PACH: un poco menos usado, algo similar al put, envia datos, editar recursos existentes de forma parcial.

            las que menos se usan:
                TRACE: solicita al servidor que introduzca en la respuesta todos los datos que reciba en la peticion. se recibe la misma info que hemos enviado, se usa para desarrollo.
                HEAD: igual que el get, solo se obtienen los encabezados, es mas rapido.
                OPTIONS: devuelve los metodos HTTP que el servidor acepta para una URL especifico. 
                CONNECT:se usa para saber si se tiene acceso a un host. si esta activa.
                UPDATE: modifica el contenido y las propiedades "obsoletas" de un recurso versionado. es decir actualiza. 
                MOVE: mover un recurso a una URL especificado en el header. seria como eliminar y post al mismo tiempo. a traves del URI. el host mas el path. 
                MKCOL: crear una coleccion en el URI especificado
                PROPFIND: obtiene las propiedades de un recurso especificado en el URI.
                PROPPATCH: permite modificar las propiedades de un recurso especificado en el URI.
                MERGE: junta dos recursos especificados en la peticion y los convierte en uno. 
                LABEL: sirve para modificar la etiqueta de un recurso. 

        RESPUESTAS HTTP: 200. todo ok. si empieza con 2 (positivo), con el 3 (falta algo en el medio), los 4 (las respuestas negativas). si empieza con 5 (tiene error interno de servidor) HTTP.CAT

API Y RESTFul: una extension del protocolo HTTP
    API: Application Programing Interface. Suponemos que tenemos una app que tiene acceso a una base de datos. la app tiene una conexion directa con la base de datos. se accede a la base de datos en funcion de una arquitectura interna, el control total del acceso a la base de datos la tiene nuestra app. Create Read Update Delete, el acceso CRUD de la app a la base. Todo esto se hace a traves de funciones, addUser, gerUsers, editUser,DeletUser; estas son las funciones que podemos utilizar para acceder y realizar operaciones dentro de la base de datos a traves de la app. lo que se conoce como API es el conjunto de funciones o metodos que nos ayudan a realizar operaciones dentro de una base de datos, sin necesidad de tocar logicas por dentro. 
    REST: protocolo. REpresentational State Transfer,es un protocolo de comunicacion. 
    RESTFul API: esto es lo que se usa. suponer que tengo una app con acceso a base de datos con acceso CRUD, desde afuera no se tiene acceso. si esa app quiere publicar cierta parte de sus datos o permitir a usuarios externos tener acceso a cierta parte de los datos, puede crear una RESTFul API. serian como una puerta pequeña al exterior a traves de las cuales pueden entrar solicitudes del exterior para acceder a informacion de base de datos. puede ser que usuarios externos tengan acceso a escrituras. esa puerta se llama API RESTFul. por ejemplo: telefonos, compus, etc, dispositivos exteriores y programas externos, a traves de ese protocolo API se acceden a ciertos datos de esa base de datos, hasta se pueden realizar cambios si la API lo permite. 

    MENSAJE Y EJEMPLO CON POSTMAN:
    ESTRUCTURA DE UN MENSAJE: mensaje REST, es como un mensaje HTTP. Peticion-respuesta. 
    En la peticion tenemos tres partes: Metodo URI VHTTP (metodo, la uri tambien es endpoint, vhttp es la version http.) en este caso el endpoint seria: http://developer.mozilla.org, la URI seria el host (toda la direccion mas el /). Tenemos tambien el HEAD, y el BODY (la info que estamos dando dentro del msj). o sea tres METODO, HEAD Y BODY. 

    APLICACION POSTMAN: mas usada para testear apis y apps que se conecten a apis. 
    cuando se intenta acceder a una app a traves de una API, las versiones publicas solo acceden informacion. si queremos tener la potestad de cambiar la info de la base de datos, tenemos que tener permiso, con autenticaciones, todas esas claves despues se ven reflejadas en el HEAD cuando hacemos una llamada. 
    usar la app de postman, crear httprequest, entrar a la api publica de por ej pokemon. 

SOAP: Simple Object Access Protocol:
    protocolo similar a REST, que tambien se usa. 
    Diferencias con REST: no es protocolo REST, es una arquitectura. SOAP si que es protocolo definido, mantenido W3C. la organizacion que define estandares. 
        Por defecto es Stateless, puede ser stateful para mantener sesiones o mutabilidad dentro del propio servidor. 
        Solo maneja XML en SOAP. en cambio REST maneja mas tipos de datos. 
        Menos flexible por ser mas definido, se necesitan mas recursos para enviar o recibir. 
        SOAP puede trabajar con HTTP , SMTP, UDP,otros. En cambio REST solo HTTP. 

INTRODUCCION A gRPC:
    es una arquitectura, framework de comunicacion entre diferentes servicios, similar a HTTP, mas moderno, creada por google. 
    Google Remote Procedure Call: transmite datos
        Tecnologia de transmision de datos serializada, mensajes binarios transmite, no son como los otros. Proto buffers para definir los servicios, permite usar muchos lenguajes de programacion, como usa tecnologia HTTP2, tiene mas velocidad de direccion, 
        Creado por google
        Bi-directional streaming (con una misma direccion puedo enviar y recibir datos modo stream)
        Multilenguaje y plataforma 
    Seria como una alternativa a los REST apis, o las SOAPs. 
    Soporta: C#, Python, PHP, Ruby, Node, kotlin, etc. 

    gRPC Stub y Protobuffer:
        Suponemos dos clientes, uno escrito por Ruby, y otro por Java. necesitan tener un stub, una parte de una app, que nos proporciona los mismos metodos que nos da el gRPC. cuando hago una solicitud lo hago a traves del stub, genero un protorequest y recibo una protoresponse. Estos servicios son archivos .proto
        Protocol Buffer: Es un mecanismo de serializacion de datos. permite que el peso de la comunicacion sea menos y mas rapido. estan transcriptos a codigo binario. 

        Se usa el protobuffer para agarrar el mensaje y serializarlo (hacerlo ceros y unos), el front entonces tiene un stap para tener acceso al ProtoBuffer, convierte el mensaje del front en mensaje binario. de esta manera, el mensaje pesa muy poco a comparacion del original, y enviarlo a traves de internet. Luego el receptor, vuelve a convertir al mensaje original en el backend para acceder a la info que le enviaron. 
        En el output se convierte y en el input se desconvierte o decodifica. esto es mas rapido, ya que es menos pesado. 

    Como se define un servicio gRPC: crear un archivo .proto, se define la estructura del mensaje que vamos a transmitir, del stap al servidor. el servicio se define: por ejemplo: se define servicio, con un request, con parametro y devuelve un mensaje. 

LICENCIAS DE SOFTWARE:
    terminos legales que afectan a la utilizacion y distribucion de cierto software. Contrato a traves del cual una persona que es el titular de los derechos de explotacion de un determinado software, establece las condiciones a traves de las cuales otra u otras personas pueden acceder a usar ese software de acuerdo con las condiciones que el mismo establecio. 
    Dos partes: Licenciante (propietario del soft) y el Licenciatario (el que usa el software). 
        Tipos de licencia de software:
            Software libre: totalmente permisible. tenemos la posibilidad de ver el codigo fuente, estudiar el codigo fuente, modificar el codigo fuente, compartir el codigo fuente, compartir las modificaciones, uso comercial (podemos venderlo) y tambien usar con cualquier fin comercial o proposito. 
            open Source: puede ver el codigo fuente, estudiarlo, no nos permite modificar el codigo fuente (algunas licencias no permiten esto), no siempre podemos compartir el codigo fuente, no siempre se comparte las modificaciones, no tiene uso comercial y limitado el uso para cualquier fin. 
            Propietaria: propiedad de una persona u organizacion. no puede hacer nada con el codigo fuente, y solamente se puede usar para cualquier fin con permiso del fabricante. 
            Freeware: Programas gratuitos pero que no podemos acceder al codigo, 
            Shareware: software distribuido gratuitamente para su prueba, trial version. estrategia de marketing muy difundida en los ultimos tiempos. 
          
            Licencias de codigo abierto permisivas:nos indican que podemos cambiar el codigo fuente. Se puede crear una obra, o modificar, versiones separadas de software, sin tener obligacion de proteccion alguna. 
                Licencia Apache, Licencia PHP, BSD,PSFL (Python Software Foundation License), o MIT (Massachussets Institute of Technology). desde cualquiera de ella podemos crear o modificar un software, esta creacion no tiene obligacion de licencia.

            Licencias de codigo abierto menos permisivas / robustas fuertes: tienen una clausula que obliga a que las obras derivadas o modificaciones que se realicen al software original se deben licenciar bajo los mismos terminos y condiciones que la licencia original. 
                EPL: Eclipse Public License
                GPL, LGPL y AGPL: GNU Public License- GNU Lesser General Public License- GNU Affero General Public License.

            Licencias de codigo abierto debiles: contiene una clausula que obliga a que las modificaciones que se realicen al software original se deban licenciar bajo los mismos terminos y condiciones de la licencia original. PERO NO OBRAS DERIVADAS. 
                MPL: Mozilla Public License
                CDDL: Common Development and Distribution License.
                APSL: Apple Source License.
                LGDL: la misma que la anterior. Lesser .....
            Si no estas seguro que licencia usar, habla con un abogado o especialista para saber que licencia poner en caso de sacar algun codigo. 

MD5 Y SHA: PROTECCION DE DATOS.
    Algoritmos mas usados hoy, de cifrado, de hash seguro. estos algoritmos sirven para codificar el mensaje, no existe para descifrar. 
        MD5: 1991, reemplaza al MD4. se puede vulnerar, o sea que no se usa tanto.Se usaba , ahora solo se usa para asegurar la integridad, comparando md5 con un software de descarga, si coinciden los dos hash, el soft es el correcto el que descargamos. 
        SHA: Secure hash Algorit: SHA-0, SHA-1. SHA-2, SHA-3. con la ayuda de la agencia de seguridad nacional yanki, se fue desarrollando y el que mas se usa ahora es el SHA-256. es un tipo de cifrado de una sola via, solo se puede cifrar. ej: las contraseñas pasan por hash, y se almacenan las contraseñas cifradas. para mas seguridad compara los cifrados de las contraseñas, para dejar entrar al usuario. 

    CRIPTOGRAFIA SIMETRICA Y ASIMETRICA:
        CRIPTOGRAFIA SIMETRICA: suponemos que quiero mandar msj a otra persona. como no confio en el canal que voy a seguir. Escribo el mensaje. yo quiero encriptar ese mensaje. tenemos que definir una clave de cifrado o encriptacion entre las dos personas que se mandan el msj. teniendo las dos personas las mismas claves. 
        Con el mensaje y la clave, yo puedo obtener un mensaje cifrado. la persona que recibe el mensaje, con la clave es capaz de descifrar el mensaje. Utiliza una clave que conocen el emisor y el receptor.

        CRIPTOGRAFIA ASIMETRICA: concepto similar, solo que metemos dos claves. la clave publica y privada. el receptor tiene clave publica y privada, la ultima solo la conoce el. Luis cifra el mensaje con la clave publica de pedro. este mensaje cifrado solo puede descifrado por la clave privada de pedro. es decir, viaja con la publica pero se descifra con la privada. 

PROTOCOLOS DE SEGURIDAD EN INTERNET:
    SSL/TLS: HTTP aparece con S, que usa una capa de seguridad adicional. Secure Sockets Layer - Transport Layer Security. Certificados X.509- Criptografia Asimetrica. ahora se usa mas TLS.  
    SSH: Secure Shell -Protocolo de comunicacion con servidores- tiene cifrado, para conexion a servidores remotos. ya viene cifrado por defecto. Se usa programa Putty para conectarnos desde windows a servidores. 
    PGP: Pretty Good Privacy. se usa en la dark web para intercambiar datos personales. software instalado con criptografia asimetrica. 

    




